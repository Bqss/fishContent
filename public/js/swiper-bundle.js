(function (e, a) { "object" == typeof exports && "undefined" != typeof module ? module.exports = a() : "function" == typeof define && define.amd ? define(a) : (e = "undefined" == typeof globalThis ? e || self : globalThis, e.Swiper = a()) })(this, function () {
        'use strict'; function e(e) { return null !== e && "object" == typeof e && "constructor" in e && e.constructor === Object } function a(s, t) { void 0 === s && (s = {}), void 0 === t && (t = {}), Object.keys(t).forEach(i => { "undefined" == typeof s[i] ? s[i] = t[i] : e(t[i]) && e(s[i]) && 0 < Object.keys(t[i]).length && a(s[i], t[i]) }) } function s() { const e = "undefined" == typeof document ? {} : document; return a(e, te), e } function t() { const e = "undefined" == typeof window ? {} : window; return a(e, ie), e } function i(e) { const a = e.__proto__; Object.defineProperty(e, "__proto__", { get() { return a }, set(e) { a.__proto__ = e } }) } function r(e) { void 0 === e && (e = []); const a = []; return e.forEach(e => { Array.isArray(e) ? a.push(...r(e)) : a.push(e) }), a } function n(e, a) { return Array.prototype.filter.call(e, a) } function l(e) { const a = []; for (let s = 0; s < e.length; s += 1)-1 === a.indexOf(e[s]) && a.push(e[s]); return a } function o(e, s) { if ("string" != typeof e) return [e]; const t = [], a = s.querySelectorAll(e); for (let r = 0; r < a.length; r += 1)t.push(a[r]); return t } function d(e, a) { const i = t(), r = s(); let n = []; if (!a && e instanceof re) return e; if (!e) return new re(n); if ("string" == typeof e) { const s = e.trim(); if (0 <= s.indexOf("<") && 0 <= s.indexOf(">")) { let e = "div"; 0 === s.indexOf("<li") && (e = "ul"), 0 === s.indexOf("<tr") && (e = "tbody"), (0 === s.indexOf("<td") || 0 === s.indexOf("<th")) && (e = "tr"), 0 === s.indexOf("<tbody") && (e = "table"), 0 === s.indexOf("<option") && (e = "select"); const a = r.createElement(e); a.innerHTML = s; for (let e = 0; e < a.childNodes.length; e += 1)n.push(a.childNodes[e]) } else n = o(e.trim(), a || r) } else if (e.nodeType || e === i || e === r) n.push(e); else if (Array.isArray(e)) { if (e instanceof re) return e; n = e } return new re(l(n)) } function p(e) { for (let a = 0; a < this.length; a += 1)this[a].style.transform = e; return this } function c(e) { if ("undefined" == typeof e) return this[0] ? this[0].innerHTML : null; for (let a = 0; a < this.length; a += 1)this[a].innerHTML = e; return this } function m(e) { if ("undefined" == typeof e) return this[0] ? this[0].textContent.trim() : null; for (let a = 0; a < this.length; a += 1)this[a].textContent = e; return this } function u(e) { const a = []; for (let s = 0, t; s < this.length; s += 1)for (t = this[s].parentNode; t;)e ? d(t).is(e) && a.push(t) : a.push(t), t = t.parentNode; return d(a) } function h(e) { let a = this; return "undefined" == typeof e ? d([]) : (a.is(e) || (a = a.parents(e).eq(0)), a) } function g(e) { const a = []; for (let s = 0; s < this.length; s += 1) { const t = this[s].children; for (let s = 0; s < t.length; s += 1)(!e || d(t[s]).is(e)) && a.push(t[s]) } return d(a) } function f(e) { const a = e; Object.keys(a).forEach(e => { try { a[e] = null } catch (a) { } try { delete a[e] } catch (a) { } }) } function v(e, a) { return void 0 === a && (a = 0), setTimeout(e, a) } function w() { return Date.now() } function b(e) { const a = t(); let s; return a.getComputedStyle && (s = a.getComputedStyle(e, null)), !s && e.currentStyle && (s = e.currentStyle), s || (s = e.style), s } function y(e, a) { void 0 === a && (a = "x"); const s = t(); let i, r, n; const l = b(e); return s.WebKitCSSMatrix ? (r = l.transform || l.webkitTransform, 6 < r.split(",").length && (r = r.split(", ").map(e => e.replace(",", ".")).join(", ")), n = new s.WebKitCSSMatrix("none" === r ? "" : r)) : (n = l.MozTransform || l.OTransform || l.MsTransform || l.msTransform || l.transform || l.getPropertyValue("transform").replace("translate(", "matrix(1, 0, 0, 1,"), i = n.toString().split(",")), "x" === a && (s.WebKitCSSMatrix ? r = n.m41 : 16 === i.length ? r = parseFloat(i[12]) : r = parseFloat(i[4])), "y" === a && (s.WebKitCSSMatrix ? r = n.m42 : 16 === i.length ? r = parseFloat(i[13]) : r = parseFloat(i[5])), r || 0 } function x(e) { return "object" == typeof e && null !== e && e.constructor && "Object" === Object.prototype.toString.call(e).slice(8, -1) } function E(e) { return "undefined" != typeof window && "undefined" != typeof window.HTMLElement ? e instanceof HTMLElement : e && (1 === e.nodeType || 11 === e.nodeType) } function C() { const e = Object(0 >= arguments.length ? void 0 : arguments[0]), a = ["__proto__", "constructor", "prototype"]; for (let s = 1; s < arguments.length; s += 1) { const t = 0 > s || arguments.length <= s ? void 0 : arguments[s]; if (void 0 !== t && null !== t && !E(t)) { const s = Object.keys(Object(t)).filter(e => 0 > a.indexOf(e)); for (let a = 0, i = s.length; a < i; a += 1) { const i = s[a], r = Object.getOwnPropertyDescriptor(t, i); void 0 !== r && r.enumerable && (x(e[i]) && x(t[i]) ? t[i].__swiper__ ? e[i] = t[i] : C(e[i], t[i]) : !x(e[i]) && x(t[i]) ? (e[i] = {}, t[i].__swiper__ ? e[i] = t[i] : C(e[i], t[i])) : e[i] = t[i]) } } } return e } function T(e, a, s) { e.style.setProperty(a, s) } function S(e) { let { swiper: a, targetPosition: s, side: i } = e; const r = t(), n = -a.translate; let l = null, o; const d = a.params.speed; a.wrapperEl.style.scrollSnapType = "none", r.cancelAnimationFrame(a.cssModeFrameID); const p = s > n ? "next" : "prev", c = (e, a) => "next" === p && e >= a || "prev" === p && e <= a, m = () => { o = new Date().getTime(), null === l && (l = o); const e = Math.max(Math.min((o - l) / d, 1), 0), t = .5 - Math.cos(e * Math.PI) / 2; let p = n + t * (s - n); return c(p, s) && (p = s), a.wrapperEl.scrollTo({ [i]: p }), c(p, s) ? (a.wrapperEl.style.overflow = "hidden", a.wrapperEl.style.scrollSnapType = "", setTimeout(() => { a.wrapperEl.style.overflow = "", a.wrapperEl.scrollTo({ [i]: p }) }), void r.cancelAnimationFrame(a.cssModeFrameID)) : void (a.cssModeFrameID = r.requestAnimationFrame(m)) }; m() } function P() { const e = t(), a = s(); return { smoothScroll: a.documentElement && "scrollBehavior" in a.documentElement.style, touch: !!("ontouchstart" in e || e.DocumentTouch && a instanceof e.DocumentTouch), passiveListener: function () { let a = !1; try { const s = Object.defineProperty({}, "passive", { get() { a = !0 } }); e.addEventListener("testPassiveListener", null, s) } catch (a) { } return a }(), gestures: function () { return "ongesturestart" in e }() } } function k() { return le || (le = P()), le } function $(e) { let { userAgent: a } = void 0 === e ? {} : e; const s = k(), i = t(), r = i.navigator.platform, n = a || i.navigator.userAgent, l = { ios: !1, android: !1 }, o = i.screen.width, d = i.screen.height, p = n.match(/(Android);?[\s\/]+([\d.]+)?/); let c = n.match(/(iPad).*OS\s([\d_]+)/); const m = n.match(/(iPod)(.*OS\s([\d_]+))?/), u = !c && n.match(/(iPhone\sOS|iOS)\s([\d_]+)/); let h = "MacIntel" === r; return !c && h && s.touch && 0 <= ["1024x1366", "1366x1024", "834x1194", "1194x834", "834x1112", "1112x834", "768x1024", "1024x768", "820x1180", "1180x820", "810x1080", "1080x810"].indexOf(`${o}x${d}`) && (c = n.match(/(Version)\/([\d.]+)/), !c && (c = [0, 1, "13_0_0"]), h = !1), p && !("Win32" === r) && (l.os = "android", l.android = !0), (c || u || m) && (l.os = "ios", l.ios = !0), l } function M(e) { return void 0 === e && (e = {}), oe || (oe = $(e)), oe } function z() { const e = t(); return { isSafari: function () { const a = e.navigator.userAgent.toLowerCase(); return 0 <= a.indexOf("safari") && 0 > a.indexOf("chrome") && 0 > a.indexOf("android") }(), isWebView: /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(e.navigator.userAgent) } } function L() { return de || (de = z()), de } function I(e) { let { swiper: a, runCallbacks: s, direction: t, step: i } = e; const { activeIndex: r, previousIndex: n } = a; let l = t; if (l || (r > n ? l = "next" : r < n ? l = "prev" : l = "reset"), a.emit(`transition${i}`), s && r !== n) { if ("reset" === l) return void a.emit(`slideResetTransition${i}`); a.emit(`slideChangeTransition${i}`), "next" === l ? a.emit(`slideNextTransition${i}`) : a.emit(`slidePrevTransition${i}`) } } function D(e, a) { function i(a) { if (!a || a === s() || a === t()) return null; a.assignedSlot && (a = a.assignedSlot); const r = a.closest(e); return r || a.getRootNode ? r || i(a.getRootNode().host) : null } return void 0 === a && (a = this), i(a) } function O(a) { const i = this, r = s(), n = t(), l = i.touchEventsData, { params: o, touches: p, enabled: c } = i; if (!c) return; if (i.animating && o.preventInteractionOnTransition) return; !i.animating && o.cssMode && o.loop && i.loopFix(); let m = a; m.originalEvent && (m = m.originalEvent); let u = d(m.target); if ("wrapper" === o.touchEventsTarget && !u.closest(i.wrapperEl).length) return; if (l.isTouchEvent = "touchstart" === m.type, !l.isTouchEvent && "which" in m && 3 === m.which) return; if (!l.isTouchEvent && "button" in m && 0 < m.button) return; if (l.isTouched && l.isMoved) return; const h = !!o.noSwipingClass && "" !== o.noSwipingClass; h && m.target && m.target.shadowRoot && a.path && a.path[0] && (u = d(a.path[0])); const g = o.noSwipingSelector ? o.noSwipingSelector : `.${o.noSwipingClass}`, f = !!(m.target && m.target.shadowRoot); if (o.noSwiping && (f ? D(g, u[0]) : u.closest(g)[0])) return void (i.allowClick = !0); if (o.swipeHandler && !u.closest(o.swipeHandler)[0]) return; p.currentX = "touchstart" === m.type ? m.targetTouches[0].pageX : m.pageX, p.currentY = "touchstart" === m.type ? m.targetTouches[0].pageY : m.pageY; const v = p.currentX, b = p.currentY, y = o.edgeSwipeDetection || o.iOSEdgeSwipeDetection, x = o.edgeSwipeThreshold || o.iOSEdgeSwipeThreshold; if (y && (v <= x || v >= n.innerWidth - x)) if ("prevent" === y) a.preventDefault(); else return; if (Object.assign(l, { isTouched: !0, isMoved: !1, allowTouchCallbacks: !0, isScrolling: void 0, startMoving: void 0 }), p.startX = v, p.startY = b, l.touchStartTime = w(), i.allowClick = !0, i.updateSize(), i.swipeDirection = void 0, 0 < o.threshold && (l.allowThresholdMove = !1), "touchstart" !== m.type) { let e = !0; u.is(l.focusableElements) && (e = !1, "SELECT" === u[0].nodeName && (l.isTouched = !1)), r.activeElement && d(r.activeElement).is(l.focusableElements) && r.activeElement !== u[0] && r.activeElement.blur(); const a = e && i.allowTouchMove && o.touchStartPreventDefault; (o.touchStartForcePreventDefault || a) && !u[0].isContentEditable && m.preventDefault() } i.params.freeMode && i.params.freeMode.enabled && i.freeMode && i.animating && !o.cssMode && i.freeMode.onTouchStart(), i.emit("touchStart", m) } function A(a) { const t = s(), i = this, r = i.touchEventsData, { params: n, touches: l, rtlTranslate: o, enabled: p } = i; if (!p) return; let c = a; if (c.originalEvent && (c = c.originalEvent), !r.isTouched) return void (r.startMoving && r.isScrolling && i.emit("touchMoveOpposite", c)); if (r.isTouchEvent && "touchmove" !== c.type) return; const m = "touchmove" === c.type && c.targetTouches && (c.targetTouches[0] || c.changedTouches[0]), u = "touchmove" === c.type ? m.pageX : c.pageX, h = "touchmove" === c.type ? m.pageY : c.pageY; if (c.preventedByNestedSwiper) return l.startX = u, void (l.startY = h); if (!i.allowTouchMove) return d(c.target).is(r.focusableElements) || (i.allowClick = !1), void (r.isTouched && (Object.assign(l, { startX: u, startY: h, currentX: u, currentY: h }), r.touchStartTime = w())); if (r.isTouchEvent && n.touchReleaseOnEdges && !n.loop) if (i.isVertical()) { if (h < l.startY && i.translate <= i.maxTranslate() || h > l.startY && i.translate >= i.minTranslate()) return r.isTouched = !1, void (r.isMoved = !1); } else if (u < l.startX && i.translate <= i.maxTranslate() || u > l.startX && i.translate >= i.minTranslate()) return; if (r.isTouchEvent && t.activeElement && c.target === t.activeElement && d(c.target).is(r.focusableElements)) return r.isMoved = !0, void (i.allowClick = !1); if (r.allowTouchCallbacks && i.emit("touchMove", c), c.targetTouches && 1 < c.targetTouches.length) return; l.currentX = u, l.currentY = h; const g = l.currentX - l.startX, f = l.currentY - l.startY; if (i.params.threshold && Math.sqrt(g ** 2 + f ** 2) < i.params.threshold) return; if ("undefined" == typeof r.isScrolling) { let e; i.isHorizontal() && l.currentY === l.startY || i.isVertical() && l.currentX === l.startX ? r.isScrolling = !1 : 25 <= g * g + f * f && (e = 180 * Math.atan2(Math.abs(f), Math.abs(g)) / Math.PI, r.isScrolling = i.isHorizontal() ? e > n.touchAngle : 90 - e > n.touchAngle) } if (r.isScrolling && i.emit("touchMoveOpposite", c), "undefined" == typeof r.startMoving && (l.currentX !== l.startX || l.currentY !== l.startY) && (r.startMoving = !0), r.isScrolling) return void (r.isTouched = !1); if (!r.startMoving) return; i.allowClick = !1, !n.cssMode && c.cancelable && c.preventDefault(), n.touchMoveStopPropagation && !n.nested && c.stopPropagation(), r.isMoved || (n.loop && !n.cssMode && i.loopFix(), r.startTranslate = i.getTranslate(), i.setTransition(0), i.animating && i.$wrapperEl.trigger("webkitTransitionEnd transitionend"), r.allowMomentumBounce = !1, n.grabCursor && (!0 === i.allowSlideNext || !0 === i.allowSlidePrev) && i.setGrabCursor(!0), i.emit("sliderFirstMove", c)), i.emit("sliderMove", c), r.isMoved = !0; let v = i.isHorizontal() ? g : f; l.diff = v, v *= n.touchRatio, o && (v = -v), i.swipeDirection = 0 < v ? "prev" : "next", r.currentTranslate = v + r.startTranslate; let b = !0, y = n.resistanceRatio; if (n.touchReleaseOnEdges && (y = 0), 0 < v && r.currentTranslate > i.minTranslate() ? (b = !1, n.resistance && (r.currentTranslate = i.minTranslate() - 1 + (-i.minTranslate() + r.startTranslate + v) ** y)) : 0 > v && r.currentTranslate < i.maxTranslate() && (b = !1, n.resistance && (r.currentTranslate = i.maxTranslate() + 1 - (i.maxTranslate() - r.startTranslate - v) ** y)), b && (c.preventedByNestedSwiper = !0), !i.allowSlideNext && "next" === i.swipeDirection && r.currentTranslate < r.startTranslate && (r.currentTranslate = r.startTranslate), !i.allowSlidePrev && "prev" === i.swipeDirection && r.currentTranslate > r.startTranslate && (r.currentTranslate = r.startTranslate), i.allowSlidePrev || i.allowSlideNext || (r.currentTranslate = r.startTranslate), 0 < n.threshold) { if (!(Math.abs(v) > n.threshold || r.allowThresholdMove)) return void (r.currentTranslate = r.startTranslate); if (!r.allowThresholdMove) return r.allowThresholdMove = !0, l.startX = l.currentX, l.startY = l.currentY, r.currentTranslate = r.startTranslate, void (l.diff = i.isHorizontal() ? l.currentX - l.startX : l.currentY - l.startY) } !n.followFinger || n.cssMode || ((n.freeMode && n.freeMode.enabled && i.freeMode || n.watchSlidesProgress) && (i.updateActiveIndex(), i.updateSlidesClasses()), i.params.freeMode && n.freeMode.enabled && i.freeMode && i.freeMode.onTouchMove(), i.updateProgress(r.currentTranslate), i.setTranslate(r.currentTranslate)) } function N(a) { const s = this, t = s.touchEventsData, { params: r, touches: n, rtlTranslate: l, slidesGrid: o, enabled: d } = s; if (!d) return; let p = a; if (p.originalEvent && (p = p.originalEvent), t.allowTouchCallbacks && s.emit("touchEnd", p), t.allowTouchCallbacks = !1, !t.isTouched) return t.isMoved && r.grabCursor && s.setGrabCursor(!1), t.isMoved = !1, void (t.startMoving = !1); r.grabCursor && t.isMoved && t.isTouched && (!0 === s.allowSlideNext || !0 === s.allowSlidePrev) && s.setGrabCursor(!1); const i = w(), c = i - t.touchStartTime; if (s.allowClick) { const e = p.path || p.composedPath && p.composedPath(); s.updateClickedSlide(e && e[0] || p.target), s.emit("tap click", p), 300 > c && 300 > i - t.lastClickTime && s.emit("doubleTap doubleClick", p) } if (t.lastClickTime = w(), v(() => { s.destroyed || (s.allowClick = !0) }), !t.isTouched || !t.isMoved || !s.swipeDirection || 0 === n.diff || t.currentTranslate === t.startTranslate) return t.isTouched = !1, t.isMoved = !1, void (t.startMoving = !1); t.isTouched = !1, t.isMoved = !1, t.startMoving = !1; let m; if (m = r.followFinger ? l ? s.translate : -s.translate : -t.currentTranslate, r.cssMode) return; if (s.params.freeMode && r.freeMode.enabled) return void s.freeMode.onTouchEnd({ currentPos: m }); let u = 0, h = s.slidesSizesGrid[0]; for (let e = 0; e < o.length; e += e < r.slidesPerGroupSkip ? 1 : r.slidesPerGroup) { const a = e < r.slidesPerGroupSkip - 1 ? 1 : r.slidesPerGroup; "undefined" == typeof o[e + a] ? m >= o[e] && (u = e, h = o[o.length - 1] - o[o.length - 2]) : m >= o[e] && m < o[e + a] && (u = e, h = o[e + a] - o[e]) } let g = null, f = null; r.rewind && (s.isBeginning ? f = s.params.virtual && s.params.virtual.enabled && s.virtual ? s.virtual.slides.length - 1 : s.slides.length - 1 : s.isEnd && (g = 0)); const b = (m - o[u]) / h, y = u < r.slidesPerGroupSkip - 1 ? 1 : r.slidesPerGroup; if (c > r.longSwipesMs) { if (!r.longSwipes) return void s.slideTo(s.activeIndex); "next" === s.swipeDirection && (b >= r.longSwipesRatio ? s.slideTo(r.rewind && s.isEnd ? g : u + y) : s.slideTo(u)), "prev" === s.swipeDirection && (b > 1 - r.longSwipesRatio ? s.slideTo(u + y) : null !== f && 0 > b && Math.abs(b) > r.longSwipesRatio ? s.slideTo(f) : s.slideTo(u)) } else { if (!r.shortSwipes) return void s.slideTo(s.activeIndex); const e = s.navigation && (p.target === s.navigation.nextEl || p.target === s.navigation.prevEl); e ? p.target === s.navigation.nextEl ? s.slideTo(u + y) : s.slideTo(u) : ("next" === s.swipeDirection && s.slideTo(null === g ? u + y : g), "prev" === s.swipeDirection && s.slideTo(null === f ? u : f)) } } function G() { const e = this, { params: a, el: s } = e; if (!(s && 0 === s.offsetWidth)) { a.breakpoints && e.setBreakpoint(); const { allowSlideNext: s, allowSlidePrev: t, snapGrid: i } = e; e.allowSlideNext = !0, e.allowSlidePrev = !0, e.updateSize(), e.updateSlides(), e.updateSlidesClasses(), ("auto" === a.slidesPerView || 1 < a.slidesPerView) && e.isEnd && !e.isBeginning && !e.params.centeredSlides ? e.slideTo(e.slides.length - 1, 0, !1, !0) : e.slideTo(e.activeIndex, 0, !1, !0), e.autoplay && e.autoplay.running && e.autoplay.paused && e.autoplay.run(), e.allowSlidePrev = t, e.allowSlideNext = s, e.params.watchOverflow && i !== e.snapGrid && e.checkOverflow() } } function B(a) { const e = this; e.enabled && (e.allowClick || (e.params.preventClicks && a.preventDefault(), e.params.preventClicksPropagation && e.animating && (a.stopPropagation(), a.stopImmediatePropagation()))) } function H() { const e = this, { wrapperEl: a, rtlTranslate: s, enabled: t } = e; if (!t) return; e.previousTranslate = e.translate, e.translate = e.isHorizontal() ? -a.scrollLeft : -a.scrollTop, 0 === e.translate && (e.translate = 0), e.updateActiveIndex(), e.updateSlidesClasses(); let i; const r = e.maxTranslate() - e.minTranslate(); i = 0 == r ? 0 : (e.translate - e.minTranslate()) / r, i !== e.progress && e.updateProgress(s ? -e.translate : e.translate), e.emit("setTranslate", e.translate, !1) } function _() { } function X() { const e = this, a = s(), { params: t, support: i } = e; e.onTouchStart = O.bind(e), e.onTouchMove = A.bind(e), e.onTouchEnd = N.bind(e), t.cssMode && (e.onScroll = H.bind(e)), e.onClick = B.bind(e), i.touch && !pe && (a.addEventListener("touchstart", _), pe = !0), ce(e, "on") } function Y() { const e = this, { activeIndex: a, initialized: s, loopedSlides: r = 0, params: t, $el: i } = e, n = t.breakpoints; if (!n || n && 0 === Object.keys(n).length) return; const l = e.getBreakpoint(n, e.params.breakpointsBase, e.el); if (!l || e.currentBreakpoint === l) return; const o = l in n ? n[l] : void 0, d = o || e.originalParams, p = me(e, t), c = me(e, d), m = t.enabled; p && !c ? (i.removeClass(`${t.containerModifierClass}grid ${t.containerModifierClass}grid-column`), e.emitContainerClasses()) : !p && c && (i.addClass(`${t.containerModifierClass}grid`), (d.grid.fill && "column" === d.grid.fill || !d.grid.fill && "column" === t.grid.fill) && i.addClass(`${t.containerModifierClass}grid-column`), e.emitContainerClasses()), ["navigation", "pagination", "scrollbar"].forEach(a => { const s = t[a] && t[a].enabled, i = d[a] && d[a].enabled; s && !i && e[a].disable(), !s && i && e[a].enable() }); const u = d.direction && d.direction !== t.direction, h = t.loop && (d.slidesPerView !== t.slidesPerView || u); u && s && e.changeDirection(), C(e.params, d); const g = e.params.enabled; Object.assign(e, { allowTouchMove: e.params.allowTouchMove, allowSlideNext: e.params.allowSlideNext, allowSlidePrev: e.params.allowSlidePrev }), m && !g ? e.disable() : !m && g && e.enable(), e.currentBreakpoint = l, e.emit("_beforeBreakpoint", d), h && s && (e.loopDestroy(), e.loopCreate(), e.updateSlides(), e.slideTo(a - r + e.loopedSlides, 0, !1)), e.emit("breakpoint", d) } function R(e, a) { const s = []; return e.forEach(e => { "object" == typeof e ? Object.keys(e).forEach(t => { e[t] && s.push(a + t) }) : "string" == typeof e && s.push(a + e) }), s } function W() { const e = this, { classNames: a, params: s, rtl: t, $el: i, device: r, support: n } = e, l = R(["initialized", s.direction, { "pointer-events": !n.touch }, { "free-mode": e.params.freeMode && s.freeMode.enabled }, { autoheight: s.autoHeight }, { rtl: t }, { grid: s.grid && 1 < s.grid.rows }, { "grid-column": s.grid && 1 < s.grid.rows && "column" === s.grid.fill }, { android: r.android }, { ios: r.ios }, { "css-mode": s.cssMode }, { centered: s.cssMode && s.centeredSlides }, { "watch-progress": s.watchSlidesProgress }], s.containerModifierClass); a.push(...l), i.addClass([...a].join(" ")), e.emitContainerClasses() } function q(e, a) { return function (s) { void 0 === s && (s = {}); const t = Object.keys(s)[0], i = s[t]; return "object" != typeof i || null === i ? void C(a, s) : (0 <= ["navigation", "pagination", "scrollbar"].indexOf(t) && !0 === e[t] && (e[t] = { auto: !0 }), t in e && "enabled" in i ? void (!0 === e[t] && (e[t] = { enabled: !0 }), "object" == typeof e[t] && !("enabled" in e[t]) && (e[t].enabled = !0), !e[t] && (e[t] = { enabled: !1 }), C(a, s)) : void C(a, s)) } } function V(e, a, t, i) { const r = s(); return e.params.createElements && Object.keys(i).forEach(s => { if (!t[s] && !0 === t.auto) { let n = e.$el.children(`.${i[s]}`)[0]; n || (n = r.createElement("div"), n.className = i[s], e.$el.append(n)), t[s] = n, a[s] = n } }), t } function F(e) { return void 0 === e && (e = ""), `.${e.trim().replace(/([\.:!\/])/g, "\\$1").replace(/ /g, ".")}` } function j(e) { const a = this, { $wrapperEl: s, params: t } = a; if (t.loop && a.loopDestroy(), "object" == typeof e && "length" in e) for (let a = 0; a < e.length; a += 1)e[a] && s.append(e[a]); else s.append(e); t.loop && a.loopCreate(), t.observer || a.update() } function K(e) { const a = this, { params: s, $wrapperEl: t, activeIndex: i } = a; s.loop && a.loopDestroy(); let r = i + 1; if ("object" == typeof e && "length" in e) { for (let a = 0; a < e.length; a += 1)e[a] && t.prepend(e[a]); r = i + e.length } else t.prepend(e); s.loop && a.loopCreate(), s.observer || a.update(), a.slideTo(r, 0, !1) } function U(e, a) { const s = this, { $wrapperEl: t, params: i, activeIndex: r } = s; let n = r; i.loop && (n -= s.loopedSlides, s.loopDestroy(), s.slides = t.children(`.${i.slideClass}`)); const l = s.slides.length; if (0 >= e) return void s.prependSlide(a); if (e >= l) return void s.appendSlide(a); let o = n > e ? n + 1 : n; const d = []; for (let t = l - 1; t >= e; t -= 1) { const e = s.slides.eq(t); e.remove(), d.unshift(e) } if ("object" == typeof a && "length" in a) { for (let e = 0; e < a.length; e += 1)a[e] && t.append(a[e]); o = n > e ? n + a.length : n } else t.append(a); for (let s = 0; s < d.length; s += 1)t.append(d[s]); i.loop && s.loopCreate(), i.observer || s.update(), i.loop ? s.slideTo(o + s.loopedSlides, 0, !1) : s.slideTo(o, 0, !1) } function Q(e) { const a = this, { params: s, $wrapperEl: t, activeIndex: i } = a; let r = i; s.loop && (r -= a.loopedSlides, a.loopDestroy(), a.slides = t.children(`.${s.slideClass}`)); let n = r, l; if ("object" == typeof e && "length" in e) { for (let s = 0; s < e.length; s += 1)l = e[s], a.slides[l] && a.slides.eq(l).remove(), l < n && (n -= 1); n = Math.max(n, 0) } else l = e, a.slides[l] && a.slides.eq(l).remove(), l < n && (n -= 1), n = Math.max(n, 0); s.loop && a.loopCreate(), s.observer || a.update(), s.loop ? a.slideTo(n + a.loopedSlides, 0, !1) : a.slideTo(n, 0, !1) } function Z() { const e = this, a = []; for (let s = 0; s < e.slides.length; s += 1)a.push(s); e.removeSlide(a) } function J(e) { const { effect: a, swiper: s, on: t, setTranslate: i, setTransition: r, overwriteParams: n, perspective: l, recreateShadows: o, getEffectParams: d } = e; t("beforeInit", () => { if (s.params.effect === a) { s.classNames.push(`${s.params.containerModifierClass}${a}`), l && l() && s.classNames.push(`${s.params.containerModifierClass}3d`); const e = n ? n() : {}; Object.assign(s.params, e), Object.assign(s.originalParams, e) } }), t("setTranslate", () => { s.params.effect !== a || i() }), t("setTransition", (e, t) => { s.params.effect !== a || r(t) }), t("transitionEnd", () => { if (s.params.effect === a && o) { if (!d || !d().slideShadows) return; s.slides.each(e => { const a = s.$(e); a.find(".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left").remove() }), o() } }); let p; t("virtualUpdate", () => { s.params.effect !== a || (!s.slides.length && (p = !0), requestAnimationFrame(() => { p && s.slides && s.slides.length && (i(), p = !1) })) }) } function ee(e, a) { return e.transformEl ? a.find(e.transformEl).css({ "backface-visibility": "hidden", "-webkit-backface-visibility": "hidden" }) : a } function ae(e) { let { swiper: a, duration: s, transformEl: t, allSlides: i } = e; const { slides: r, activeIndex: n, $wrapperEl: l } = a; if (a.params.virtualTranslate && 0 !== s) { let e = !1, s; s = i ? t ? r.find(t) : r : t ? r.eq(n).find(t) : r.eq(n), s.transitionEnd(() => { if (!e && a && !a.destroyed) { e = !0, a.animating = !1; const s = ["webkitTransitionEnd", "transitionend"]; for (let e = 0; e < s.length; e += 1)l.trigger(s[e]) } }) } } function se(e, a, s) { const t = `swiper-slide-shadow${s ? `-${s}` : ""}`, i = e.transformEl ? a.find(e.transformEl) : a; let r = i.children(`.${t}`); return r.length || (r = d(`<div class="swiper-slide-shadow${s ? `-${s}` : ""}"></div>`), i.append(r)), r } const te = { body: {}, addEventListener() { }, removeEventListener() { }, activeElement: { blur() { }, nodeName: "" }, querySelector() { return null }, querySelectorAll() { return [] }, getElementById() { return null }, createEvent() { return { initEvent() { } } }, createElement() { return { children: [], childNodes: [], style: {}, setAttribute() { }, getElementsByTagName() { return [] } } }, createElementNS() { return {} }, importNode() { return null }, location: { hash: "", host: "", hostname: "", href: "", origin: "", pathname: "", protocol: "", search: "" } }, ie = { document: te, navigator: { userAgent: "" }, location: { hash: "", host: "", hostname: "", href: "", origin: "", pathname: "", protocol: "", search: "" }, history: { replaceState() { }, pushState() { }, go() { }, back() { } }, CustomEvent: function () { return this }, addEventListener() { }, removeEventListener() { }, getComputedStyle() { return { getPropertyValue() { return "" } } }, Image() { }, Date() { }, screen: {}, setTimeout() { }, clearTimeout() { }, matchMedia() { return {} }, requestAnimationFrame(e) { return "undefined" == typeof setTimeout ? (e(), null) : setTimeout(e, 0) }, cancelAnimationFrame(e) { "undefined" == typeof setTimeout || clearTimeout(e) } }; class re extends Array { constructor(e) { "number" == typeof e ? super(e) : (super(...(e || [])), i(this)) } } d.fn = re.prototype; const ne = { addClass: function () { for (var e = arguments.length, a = Array(e), s = 0; s < e; s++)a[s] = arguments[s]; const t = r(a.map(e => e.split(" "))); return this.forEach(e => { e.classList.add(...t) }), this }, removeClass: function () { for (var e = arguments.length, a = Array(e), s = 0; s < e; s++)a[s] = arguments[s]; const t = r(a.map(e => e.split(" "))); return this.forEach(e => { e.classList.remove(...t) }), this }, hasClass: function () { for (var e = arguments.length, a = Array(e), s = 0; s < e; s++)a[s] = arguments[s]; const t = r(a.map(e => e.split(" "))); return 0 < n(this, e => 0 < t.filter(a => e.classList.contains(a)).length).length }, toggleClass: function () { for (var e = arguments.length, a = Array(e), s = 0; s < e; s++)a[s] = arguments[s]; const t = r(a.map(e => e.split(" "))); this.forEach(e => { t.forEach(a => { e.classList.toggle(a) }) }) }, attr: function (e, a) { if (1 === arguments.length && "string" == typeof e) return this[0] ? this[0].getAttribute(e) : void 0; for (let s = 0; s < this.length; s += 1)if (2 === arguments.length) this[s].setAttribute(e, a); else for (const a in e) this[s][a] = e[a], this[s].setAttribute(a, e[a]); return this }, removeAttr: function (e) { for (let a = 0; a < this.length; a += 1)this[a].removeAttribute(e); return this }, transform: p, transition: function (e) { for (let a = 0; a < this.length; a += 1)this[a].style.transitionDuration = "string" == typeof e ? e : `${e}ms`; return this }, on: function () { function e(a) { const e = a.target; if (e) { const s = a.target.dom7EventData || []; if (0 > s.indexOf(a) && s.unshift(a), d(e).is(n)) l.apply(e, s); else { const a = d(e).parents(); for (let e = 0; e < a.length; e += 1)d(a[e]).is(n) && l.apply(a[e], s) } } } function a(a) { const e = a && a.target ? a.target.dom7EventData || [] : []; 0 > e.indexOf(a) && e.unshift(a), l.apply(this, e) } for (var s = arguments.length, t = Array(s), i = 0; i < s; i++)t[i] = arguments[i]; let [r, n, l, o] = t; "function" == typeof t[1] && ([r, l, o] = t, n = void 0), o || (o = !1); const p = r.split(" "); let c; for (let s = 0; s < this.length; s += 1) { const t = this[s]; if (!n) for (c = 0; c < p.length; c += 1) { const e = p[c]; t.dom7Listeners || (t.dom7Listeners = {}), t.dom7Listeners[e] || (t.dom7Listeners[e] = []), t.dom7Listeners[e].push({ listener: l, proxyListener: a }), t.addEventListener(e, a, o) } else for (c = 0; c < p.length; c += 1) { const a = p[c]; t.dom7LiveListeners || (t.dom7LiveListeners = {}), t.dom7LiveListeners[a] || (t.dom7LiveListeners[a] = []), t.dom7LiveListeners[a].push({ listener: l, proxyListener: e }), t.addEventListener(a, e, o) } } return this }, off: function () { for (var e = arguments.length, a = Array(e), s = 0; s < e; s++)a[s] = arguments[s]; let [t, i, r, n] = a; "function" == typeof a[1] && ([t, r, n] = a, i = void 0), n || (n = !1); const l = t.split(" "); for (let e = 0; e < l.length; e += 1) { const a = l[e]; for (let e = 0; e < this.length; e += 1) { const s = this[e]; let t; if (!i && s.dom7Listeners ? t = s.dom7Listeners[a] : i && s.dom7LiveListeners && (t = s.dom7LiveListeners[a]), t && t.length) for (let e = t.length - 1; 0 <= e; e -= 1) { const i = t[e]; r && i.listener === r ? (s.removeEventListener(a, i.proxyListener, n), t.splice(e, 1)) : r && i.listener && i.listener.dom7proxy && i.listener.dom7proxy === r ? (s.removeEventListener(a, i.proxyListener, n), t.splice(e, 1)) : !r && (s.removeEventListener(a, i.proxyListener, n), t.splice(e, 1)) } } } return this }, trigger: function () { const e = t(); for (var a = arguments.length, s = Array(a), i = 0; i < a; i++)s[i] = arguments[i]; const r = s[0].split(" "), n = s[1]; for (let a = 0; a < r.length; a += 1) { const t = r[a]; for (let a = 0; a < this.length; a += 1) { const i = this[a]; if (e.CustomEvent) { const a = new e.CustomEvent(t, { detail: n, bubbles: !0, cancelable: !0 }); i.dom7EventData = s.filter((e, a) => 0 < a), i.dispatchEvent(a), i.dom7EventData = [], delete i.dom7EventData } } } return this }, transitionEnd: function (a) { function s(i) { i.target !== this || (a.call(this, i), t.off("transitionend", s)) } const t = this; return a && t.on("transitionend", s), this }, outerWidth: function (e) { if (0 < this.length) { if (e) { const e = this.styles(); return this[0].offsetWidth + parseFloat(e.getPropertyValue("margin-right")) + parseFloat(e.getPropertyValue("margin-left")) } return this[0].offsetWidth } return null }, outerHeight: function (e) { if (0 < this.length) { if (e) { const e = this.styles(); return this[0].offsetHeight + parseFloat(e.getPropertyValue("margin-top")) + parseFloat(e.getPropertyValue("margin-bottom")) } return this[0].offsetHeight } return null }, styles: function () { const e = t(); return this[0] ? e.getComputedStyle(this[0], null) : {} }, offset: function () { if (0 < this.length) { const e = t(), a = s(), i = this[0], r = i.getBoundingClientRect(), n = a.body, l = i.clientTop || n.clientTop || 0, o = i.clientLeft || n.clientLeft || 0, d = i === e ? e.scrollY : i.scrollTop, p = i === e ? e.scrollX : i.scrollLeft; return { top: r.top + d - l, left: r.left + p - o } } return null }, css: function (e, a) { const s = t(); let r; if (1 === arguments.length) { if ("string" != typeof e) { for (r = 0; r < this.length; r += 1)for (const a in e) this[r].style[a] = e[a]; return this } if (this[0]) return s.getComputedStyle(this[0], null).getPropertyValue(e) } if (2 === arguments.length && "string" == typeof e) { for (r = 0; r < this.length; r += 1)this[r].style[e] = a; return this } return this }, each: function (e) { return e ? (this.forEach((a, s) => { e.apply(a, [a, s]) }), this) : this }, html: c, text: m, is: function (e) { const a = t(), r = s(), n = this[0]; let l, o; if (!n || "undefined" == typeof e) return !1; if ("string" == typeof e) { if (n.matches) return n.matches(e); if (n.webkitMatchesSelector) return n.webkitMatchesSelector(e); if (n.msMatchesSelector) return n.msMatchesSelector(e); for (l = d(e), o = 0; o < l.length; o += 1)if (l[o] === n) return !0; return !1 } if (e === r) return n === r; if (e === a) return n === a; if (e.nodeType || e instanceof re) { for (l = e.nodeType ? [e] : e, o = 0; o < l.length; o += 1)if (l[o] === n) return !0; return !1 } return !1 }, index: function () { let e = this[0], a; if (e) { for (a = 0; null !== (e = e.previousSibling);)1 === e.nodeType && (a += 1); return a } }, eq: function (e) { if ("undefined" == typeof e) return this; const a = this.length; if (e > a - 1) return d([]); if (0 > e) { const s = a + e; return 0 > s ? d([]) : d([this[s]]) } return d([this[e]]) }, append: function () { let e; const a = s(); for (let s = 0; s < arguments.length; s += 1) { e = 0 > s || arguments.length <= s ? void 0 : arguments[s]; for (let s = 0; s < this.length; s += 1)if ("string" == typeof e) { const t = a.createElement("div"); for (t.innerHTML = e; t.firstChild;)this[s].appendChild(t.firstChild) } else if (e instanceof re) for (let a = 0; a < e.length; a += 1)this[s].appendChild(e[a]); else this[s].appendChild(e) } return this }, prepend: function (e) { const a = s(); let t, r; for (t = 0; t < this.length; t += 1)if ("string" == typeof e) { const s = a.createElement("div"); for (s.innerHTML = e, r = s.childNodes.length - 1; 0 <= r; r -= 1)this[t].insertBefore(s.childNodes[r], this[t].childNodes[0]) } else if (e instanceof re) for (r = 0; r < e.length; r += 1)this[t].insertBefore(e[r], this[t].childNodes[0]); else this[t].insertBefore(e, this[t].childNodes[0]); return this }, next: function (e) { return 0 < this.length ? e ? this[0].nextElementSibling && d(this[0].nextElementSibling).is(e) ? d([this[0].nextElementSibling]) : d([]) : this[0].nextElementSibling ? d([this[0].nextElementSibling]) : d([]) : d([]) }, nextAll: function (e) { const a = []; let s = this[0]; if (!s) return d([]); for (; s.nextElementSibling;) { const t = s.nextElementSibling; e ? d(t).is(e) && a.push(t) : a.push(t), s = t } return d(a) }, prev: function (e) { if (0 < this.length) { const a = this[0]; return e ? a.previousElementSibling && d(a.previousElementSibling).is(e) ? d([a.previousElementSibling]) : d([]) : a.previousElementSibling ? d([a.previousElementSibling]) : d([]) } return d([]) }, prevAll: function (e) { const a = []; let s = this[0]; if (!s) return d([]); for (; s.previousElementSibling;) { const t = s.previousElementSibling; e ? d(t).is(e) && a.push(t) : a.push(t), s = t } return d(a) }, parent: function (e) { const a = []; for (let s = 0; s < this.length; s += 1)null !== this[s].parentNode && (e ? d(this[s].parentNode).is(e) && a.push(this[s].parentNode) : a.push(this[s].parentNode)); return d(a) }, parents: u, closest: h, find: function (e) { const a = []; for (let s = 0; s < this.length; s += 1) { const t = this[s].querySelectorAll(e); for (let e = 0; e < t.length; e += 1)a.push(t[e]) } return d(a) }, children: g, filter: function (e) { const a = n(this, e); return d(a) }, remove: function () { for (let e = 0; e < this.length; e += 1)this[e].parentNode && this[e].parentNode.removeChild(this[e]); return this } }; Object.keys(ne).forEach(e => { Object.defineProperty(d.fn, e, { value: ne[e], writable: !0 }) }); let le, oe, de; let pe = !1; const ce = (e, a) => { const t = s(), { params: i, touchEvents: r, el: n, wrapperEl: l, device: o, support: d } = e, p = !!i.nested, c = "on" === a ? "addEventListener" : "removeEventListener", m = a; if (!d.touch) n[c](r.start, e.onTouchStart, !1), t[c](r.move, e.onTouchMove, p), t[c](r.end, e.onTouchEnd, !1); else { const a = !!("touchstart" === r.start && d.passiveListener && i.passiveListeners) && { passive: !0, capture: !1 }; n[c](r.start, e.onTouchStart, a), n[c](r.move, e.onTouchMove, d.passiveListener ? { passive: !1, capture: p } : p), n[c](r.end, e.onTouchEnd, a), r.cancel && n[c](r.cancel, e.onTouchEnd, a) } (i.preventClicks || i.preventClicksPropagation) && n[c]("click", e.onClick, !0), i.cssMode && l[c]("scroll", e.onScroll), i.updateOnWindowResize ? e[m](o.ios || o.android ? "resize orientationchange observerUpdate" : "resize observerUpdate", G, !0) : e[m]("observerUpdate", G, !0) }; const me = (e, a) => e.grid && a.grid && 1 < a.grid.rows; var ue = { init: !0, direction: "horizontal", touchEventsTarget: "wrapper", initialSlide: 0, speed: 300, cssMode: !1, updateOnWindowResize: !0, resizeObserver: !0, nested: !1, createElements: !1, enabled: !0, focusableElements: "input, select, option, textarea, button, video, label", width: null, height: null, preventInteractionOnTransition: !1, userAgent: null, url: null, edgeSwipeDetection: !1, edgeSwipeThreshold: 20, autoHeight: !1, setWrapperSize: !1, virtualTranslate: !1, effect: "slide", breakpoints: void 0, breakpointsBase: "window", spaceBetween: 0, slidesPerView: 1, slidesPerGroup: 1, slidesPerGroupSkip: 0, slidesPerGroupAuto: !1, centeredSlides: !1, centeredSlidesBounds: !1, slidesOffsetBefore: 0, slidesOffsetAfter: 0, normalizeSlideIndex: !0, centerInsufficientSlides: !1, watchOverflow: !0, roundLengths: !1, touchRatio: 1, touchAngle: 45, simulateTouch: !0, shortSwipes: !0, longSwipes: !0, longSwipesRatio: .5, longSwipesMs: 300, followFinger: !0, allowTouchMove: !0, threshold: 0, touchMoveStopPropagation: !1, touchStartPreventDefault: !0, touchStartForcePreventDefault: !1, touchReleaseOnEdges: !1, uniqueNavElements: !0, resistance: !0, resistanceRatio: .85, watchSlidesProgress: !1, grabCursor: !1, preventClicks: !0, preventClicksPropagation: !0, slideToClickedSlide: !1, preloadImages: !0, updateOnImagesReady: !0, loop: !1, loopAdditionalSlides: 0, loopedSlides: null, loopedSlidesLimit: !0, loopFillGroupWithBlank: !1, loopPreventsSlide: !0, rewind: !1, allowSlidePrev: !0, allowSlideNext: !0, swipeHandler: null, noSwiping: !0, noSwipingClass: "swiper-no-swiping", noSwipingSelector: null, passiveListeners: !0, maxBackfaceHiddenSlides: 10, containerModifierClass: "swiper-", slideClass: "swiper-slide", slideBlankClass: "swiper-slide-invisible-blank", slideActiveClass: "swiper-slide-active", slideDuplicateActiveClass: "swiper-slide-duplicate-active", slideVisibleClass: "swiper-slide-visible", slideDuplicateClass: "swiper-slide-duplicate", slideNextClass: "swiper-slide-next", slideDuplicateNextClass: "swiper-slide-duplicate-next", slidePrevClass: "swiper-slide-prev", slideDuplicatePrevClass: "swiper-slide-duplicate-prev", wrapperClass: "swiper-wrapper", runCallbacksOnInit: !0, _emitClasses: !1 }; const he = { eventsEmitter: { on(e, a, s) { const t = this; if (!t.eventsListeners || t.destroyed) return t; if ("function" != typeof a) return t; const i = s ? "unshift" : "push"; return e.split(" ").forEach(e => { t.eventsListeners[e] || (t.eventsListeners[e] = []), t.eventsListeners[e][i](a) }), t }, once(e, a, s) { function t() { i.off(e, t), t.__emitterProxy && delete t.__emitterProxy; for (var s = arguments.length, r = Array(s), n = 0; n < s; n++)r[n] = arguments[n]; a.apply(i, r) } const i = this; return !i.eventsListeners || i.destroyed ? i : "function" == typeof a ? (t.__emitterProxy = a, i.on(e, t, s)) : i }, onAny(e, a) { const s = this; if (!s.eventsListeners || s.destroyed) return s; if ("function" != typeof e) return s; const t = a ? "unshift" : "push"; return 0 > s.eventsAnyListeners.indexOf(e) && s.eventsAnyListeners[t](e), s }, offAny(e) { const a = this; if (!a.eventsListeners || a.destroyed) return a; if (!a.eventsAnyListeners) return a; const s = a.eventsAnyListeners.indexOf(e); return 0 <= s && a.eventsAnyListeners.splice(s, 1), a }, off(e, a) { const s = this; return !s.eventsListeners || s.destroyed ? s : s.eventsListeners ? (e.split(" ").forEach(e => { "undefined" == typeof a ? s.eventsListeners[e] = [] : s.eventsListeners[e] && s.eventsListeners[e].forEach((t, i) => { (t === a || t.__emitterProxy && t.__emitterProxy === a) && s.eventsListeners[e].splice(i, 1) }) }), s) : s }, emit() { const e = this; if (!e.eventsListeners || e.destroyed) return e; if (!e.eventsListeners) return e; let a, s, t; for (var i = arguments.length, r = Array(i), n = 0; n < i; n++)r[n] = arguments[n]; "string" == typeof r[0] || Array.isArray(r[0]) ? (a = r[0], s = r.slice(1, r.length), t = e) : (a = r[0].events, s = r[0].data, t = r[0].context || e), s.unshift(t); const l = Array.isArray(a) ? a : a.split(" "); return l.forEach(a => { e.eventsAnyListeners && e.eventsAnyListeners.length && e.eventsAnyListeners.forEach(e => { e.apply(t, [a, ...s]) }), e.eventsListeners && e.eventsListeners[a] && e.eventsListeners[a].forEach(e => { e.apply(t, s) }) }), e } }, update: { updateSize: function () { const e = this; let a, s; const t = e.$el; a = "undefined" != typeof e.params.width && null !== e.params.width ? e.params.width : t[0].clientWidth, s = "undefined" != typeof e.params.height && null !== e.params.height ? e.params.height : t[0].clientHeight, 0 === a && e.isHorizontal() || 0 === s && e.isVertical() || (a = a - parseInt(t.css("padding-left") || 0, 10) - parseInt(t.css("padding-right") || 0, 10), s = s - parseInt(t.css("padding-top") || 0, 10) - parseInt(t.css("padding-bottom") || 0, 10), Number.isNaN(a) && (a = 0), Number.isNaN(s) && (s = 0), Object.assign(e, { width: a, height: s, size: e.isHorizontal() ? a : s })) }, updateSlides: function () { function e(e) { return s.isHorizontal() ? e : { width: "height", "margin-top": "margin-left", "margin-bottom ": "margin-right", "margin-left": "margin-top", "margin-right": "margin-bottom", "padding-left": "padding-top", "padding-right": "padding-bottom", marginRight: "marginBottom" }[e] } function a(a, s) { return parseFloat(a.getPropertyValue(e(s)) || 0) } const s = this, t = s.params, { $wrapperEl: i, size: r, rtlTranslate: n, wrongRTL: l } = s, o = s.virtual && t.virtual.enabled, d = o ? s.virtual.slides.length : s.slides.length, p = i.children(`.${s.params.slideClass}`), c = o ? s.virtual.slides.length : p.length; let m = []; const u = [], h = []; let g = t.slidesOffsetBefore; "function" == typeof g && (g = t.slidesOffsetBefore.call(s)); let f = t.slidesOffsetAfter; "function" == typeof f && (f = t.slidesOffsetAfter.call(s)); const v = s.snapGrid.length, w = s.slidesGrid.length; let b = t.spaceBetween, y = -g, x = 0, E = 0; if ("undefined" == typeof r) return; "string" == typeof b && 0 <= b.indexOf("%") && (b = parseFloat(b.replace("%", "")) / 100 * r), s.virtualSize = -b, n ? p.css({ marginLeft: "", marginBottom: "", marginTop: "" }) : p.css({ marginRight: "", marginBottom: "", marginTop: "" }), t.centeredSlides && t.cssMode && (T(s.wrapperEl, "--swiper-centered-offset-before", ""), T(s.wrapperEl, "--swiper-centered-offset-after", "")); const C = t.grid && 1 < t.grid.rows && s.grid; C && s.grid.initSlides(c); let S; const P = "auto" === t.slidesPerView && t.breakpoints && 0 < Object.keys(t.breakpoints).filter(e => "undefined" != typeof t.breakpoints[e].slidesPerView).length; for (let n = 0; n < c; n += 1) { S = 0; const i = p.eq(n); if (C && s.grid.updateSlide(n, i, c, e), "none" !== i.css("display")) { if ("auto" === t.slidesPerView) { P && (p[n].style[e("width")] = ``); const r = getComputedStyle(i[0]), l = i[0].style.transform, o = i[0].style.webkitTransform; if (l && (i[0].style.transform = "none"), o && (i[0].style.webkitTransform = "none"), t.roundLengths) S = s.isHorizontal() ? i.outerWidth(!0) : i.outerHeight(!0); else { const e = a(r, "width"), s = a(r, "padding-left"), t = a(r, "padding-right"), n = a(r, "margin-left"), l = a(r, "margin-right"), o = r.getPropertyValue("box-sizing"); if (o && "border-box" === o) S = e + n + l; else { const { clientWidth: a, offsetWidth: r } = i[0]; S = e + s + t + n + l + (r - a) } } l && (i[0].style.transform = l), o && (i[0].style.webkitTransform = o), t.roundLengths && (S = Math.floor(S)) } else S = (r - (t.slidesPerView - 1) * b) / t.slidesPerView, t.roundLengths && (S = Math.floor(S)), p[n] && (p[n].style[e("width")] = `${S}px`); p[n] && (p[n].swiperSlideSize = S), h.push(S), t.centeredSlides ? (y = y + S / 2 + x / 2 + b, 0 === x && 0 !== n && (y = y - r / 2 - b), 0 === n && (y = y - r / 2 - b), Math.abs(y) < 1 / 1e3 && (y = 0), t.roundLengths && (y = Math.floor(y)), 0 == E % t.slidesPerGroup && m.push(y), u.push(y)) : (t.roundLengths && (y = Math.floor(y)), 0 == (E - Math.min(s.params.slidesPerGroupSkip, E)) % s.params.slidesPerGroup && m.push(y), u.push(y), y = y + S + b), s.virtualSize += S + b, x = S, E += 1 } } if (s.virtualSize = Math.max(s.virtualSize, r) + f, n && l && ("slide" === t.effect || "coverflow" === t.effect) && i.css({ width: `${s.virtualSize + t.spaceBetween}px` }), t.setWrapperSize && i.css({ [e("width")]: `${s.virtualSize + t.spaceBetween}px` }), C && s.grid.updateWrapperSize(S, m, e), !t.centeredSlides) { const e = []; for (let a = 0, i; a < m.length; a += 1)i = m[a], t.roundLengths && (i = Math.floor(i)), m[a] <= s.virtualSize - r && e.push(i); m = e, 1 < Math.floor(s.virtualSize - r) - Math.floor(m[m.length - 1]) && m.push(s.virtualSize - r) } if (0 === m.length && (m = [0]), 0 !== t.spaceBetween) { const a = s.isHorizontal() && n ? "marginLeft" : e("marginRight"); p.filter((e, a) => !t.cssMode || a !== p.length - 1).css({ [a]: `${b}px` }) } if (t.centeredSlides && t.centeredSlidesBounds) { let e = 0; h.forEach(a => { e += a + (t.spaceBetween ? t.spaceBetween : 0) }), e -= t.spaceBetween; const a = e - r; m = m.map(e => 0 > e ? -g : e > a ? a + f : e) } if (t.centerInsufficientSlides) { let e = 0; if (h.forEach(a => { e += a + (t.spaceBetween ? t.spaceBetween : 0) }), e -= t.spaceBetween, e < r) { const a = (r - e) / 2; m.forEach((e, s) => { m[s] = e - a }), u.forEach((e, s) => { u[s] = e + a }) } } if (Object.assign(s, { slides: p, snapGrid: m, slidesGrid: u, slidesSizesGrid: h }), t.centeredSlides && t.cssMode && !t.centeredSlidesBounds) { T(s.wrapperEl, "--swiper-centered-offset-before", `${-m[0]}px`), T(s.wrapperEl, "--swiper-centered-offset-after", `${s.size / 2 - h[h.length - 1] / 2}px`); const e = -s.snapGrid[0], a = -s.slidesGrid[0]; s.snapGrid = s.snapGrid.map(a => a + e), s.slidesGrid = s.slidesGrid.map(e => e + a) } if (c !== d && s.emit("slidesLengthChange"), m.length !== v && (s.params.watchOverflow && s.checkOverflow(), s.emit("snapGridLengthChange")), u.length !== w && s.emit("slidesGridLengthChange"), t.watchSlidesProgress && s.updateSlidesOffset(), !o && !t.cssMode && ("slide" === t.effect || "fade" === t.effect)) { const e = `${t.containerModifierClass}backface-hidden`, a = s.$el.hasClass(e); c <= t.maxBackfaceHiddenSlides ? !a && s.$el.addClass(e) : a && s.$el.removeClass(e) } }, updateAutoHeight: function (e) { const a = this, s = [], t = a.virtual && a.params.virtual.enabled; let r = 0, n; "number" == typeof e ? a.setTransition(e) : !0 === e && a.setTransition(a.params.speed); const l = e => t ? a.slides.filter(a => parseInt(a.getAttribute("data-swiper-slide-index"), 10) === e)[0] : a.slides.eq(e)[0]; if (!("auto" !== a.params.slidesPerView && 1 < a.params.slidesPerView)) s.push(l(a.activeIndex)); else if (a.params.centeredSlides) (a.visibleSlides || d([])).each(e => { s.push(e) }); else for (n = 0; n < Math.ceil(a.params.slidesPerView); n += 1) { const e = a.activeIndex + n; if (e > a.slides.length && !t) break; s.push(l(e)) } for (n = 0; n < s.length; n += 1)if ("undefined" != typeof s[n]) { const e = s[n].offsetHeight; r = e > r ? e : r } (r || 0 === r) && a.$wrapperEl.css("height", `${r}px`) }, updateSlidesOffset: function () { const e = this, a = e.slides; for (let s = 0; s < a.length; s += 1)a[s].swiperSlideOffset = e.isHorizontal() ? a[s].offsetLeft : a[s].offsetTop }, updateSlidesProgress: function (e) { void 0 === e && (e = this && this.translate || 0); const a = this, s = a.params, { slides: t, rtlTranslate: r, snapGrid: n } = a; if (0 === t.length) return; "undefined" == typeof t[0].swiperSlideOffset && a.updateSlidesOffset(); let l = -e; r && (l = e), t.removeClass(s.slideVisibleClass), a.visibleSlidesIndexes = [], a.visibleSlides = []; for (let o = 0; o < t.length; o += 1) { const e = t[o]; let i = e.swiperSlideOffset; s.cssMode && s.centeredSlides && (i -= t[0].swiperSlideOffset); const d = (l + (s.centeredSlides ? a.minTranslate() : 0) - i) / (e.swiperSlideSize + s.spaceBetween), p = (l - n[0] + (s.centeredSlides ? a.minTranslate() : 0) - i) / (e.swiperSlideSize + s.spaceBetween), c = -(l - i), m = c + a.slidesSizesGrid[o], u = 0 <= c && c < a.size - 1 || 1 < m && m <= a.size || 0 >= c && m >= a.size; u && (a.visibleSlides.push(e), a.visibleSlidesIndexes.push(o), t.eq(o).addClass(s.slideVisibleClass)), e.progress = r ? -d : d, e.originalProgress = r ? -p : p } a.visibleSlides = d(a.visibleSlides) }, updateProgress: function (e) { const a = this; if ("undefined" == typeof e) { const s = a.rtlTranslate ? -1 : 1; e = a && a.translate && a.translate * s || 0 } const s = a.params, t = a.maxTranslate() - a.minTranslate(); let { progress: i, isBeginning: r, isEnd: n } = a; const l = r, o = n; 0 === t ? (i = 0, r = !0, n = !0) : (i = (e - a.minTranslate()) / t, r = 0 >= i, n = 1 <= i), Object.assign(a, { progress: i, isBeginning: r, isEnd: n }), (s.watchSlidesProgress || s.centeredSlides && s.autoHeight) && a.updateSlidesProgress(e), r && !l && a.emit("reachBeginning toEdge"), n && !o && a.emit("reachEnd toEdge"), (l && !r || o && !n) && a.emit("fromEdge"), a.emit("progress", i) }, updateSlidesClasses: function () { const e = this, { slides: a, params: s, $wrapperEl: t, activeIndex: i, realIndex: r } = e, n = e.virtual && s.virtual.enabled; a.removeClass(`${s.slideActiveClass} ${s.slideNextClass} ${s.slidePrevClass} ${s.slideDuplicateActiveClass} ${s.slideDuplicateNextClass} ${s.slideDuplicatePrevClass}`); let l; l = n ? e.$wrapperEl.find(`.${s.slideClass}[data-swiper-slide-index="${i}"]`) : a.eq(i), l.addClass(s.slideActiveClass), s.loop && (l.hasClass(s.slideDuplicateClass) ? t.children(`.${s.slideClass}:not(.${s.slideDuplicateClass})[data-swiper-slide-index="${r}"]`).addClass(s.slideDuplicateActiveClass) : t.children(`.${s.slideClass}.${s.slideDuplicateClass}[data-swiper-slide-index="${r}"]`).addClass(s.slideDuplicateActiveClass)); let o = l.nextAll(`.${s.slideClass}`).eq(0).addClass(s.slideNextClass); s.loop && 0 === o.length && (o = a.eq(0), o.addClass(s.slideNextClass)); let d = l.prevAll(`.${s.slideClass}`).eq(0).addClass(s.slidePrevClass); s.loop && 0 === d.length && (d = a.eq(-1), d.addClass(s.slidePrevClass)), s.loop && (o.hasClass(s.slideDuplicateClass) ? t.children(`.${s.slideClass}:not(.${s.slideDuplicateClass})[data-swiper-slide-index="${o.attr("data-swiper-slide-index")}"]`).addClass(s.slideDuplicateNextClass) : t.children(`.${s.slideClass}.${s.slideDuplicateClass}[data-swiper-slide-index="${o.attr("data-swiper-slide-index")}"]`).addClass(s.slideDuplicateNextClass), d.hasClass(s.slideDuplicateClass) ? t.children(`.${s.slideClass}:not(.${s.slideDuplicateClass})[data-swiper-slide-index="${d.attr("data-swiper-slide-index")}"]`).addClass(s.slideDuplicatePrevClass) : t.children(`.${s.slideClass}.${s.slideDuplicateClass}[data-swiper-slide-index="${d.attr("data-swiper-slide-index")}"]`).addClass(s.slideDuplicatePrevClass)), e.emitSlidesClasses() }, updateActiveIndex: function (e) { const a = this, s = a.rtlTranslate ? a.translate : -a.translate, { slidesGrid: t, snapGrid: i, params: r, activeIndex: n, realIndex: l, snapIndex: o } = a; let d = e, p; if ("undefined" == typeof d) { for (let e = 0; e < t.length; e += 1)"undefined" == typeof t[e + 1] ? s >= t[e] && (d = e) : s >= t[e] && s < t[e + 1] - (t[e + 1] - t[e]) / 2 ? d = e : s >= t[e] && s < t[e + 1] && (d = e + 1); r.normalizeSlideIndex && (0 > d || "undefined" == typeof d) && (d = 0) } if (0 <= i.indexOf(s)) p = i.indexOf(s); else { const e = Math.min(r.slidesPerGroupSkip, d); p = e + Math.floor((d - e) / r.slidesPerGroup) } if (p >= i.length && (p = i.length - 1), d === n) return void (p !== o && (a.snapIndex = p, a.emit("snapIndexChange"))); const c = parseInt(a.slides.eq(d).attr("data-swiper-slide-index") || d, 10); Object.assign(a, { snapIndex: p, realIndex: c, previousIndex: n, activeIndex: d }), a.emit("activeIndexChange"), a.emit("snapIndexChange"), l !== c && a.emit("realIndexChange"), (a.initialized || a.params.runCallbacksOnInit) && a.emit("slideChange") }, updateClickedSlide: function (a) { const e = this, s = e.params, t = d(a).closest(`.${s.slideClass}`)[0]; let r = !1, n; if (t) for (let a = 0; a < e.slides.length; a += 1)if (e.slides[a] === t) { r = !0, n = a; break } if (t && r) e.clickedSlide = t, e.clickedIndex = e.virtual && e.params.virtual.enabled ? parseInt(d(t).attr("data-swiper-slide-index"), 10) : n; else return e.clickedSlide = void 0, void (e.clickedIndex = void 0); s.slideToClickedSlide && void 0 !== e.clickedIndex && e.clickedIndex !== e.activeIndex && e.slideToClickedSlide() } }, translate: { getTranslate: function (e) { void 0 === e && (e = this.isHorizontal() ? "x" : "y"); const a = this, { params: s, rtlTranslate: t, translate: i, $wrapperEl: r } = a; if (s.virtualTranslate) return t ? -i : i; if (s.cssMode) return i; let n = y(r[0], e); return t && (n = -n), n || 0 }, setTranslate: function (e, a) { const s = this, { rtlTranslate: t, params: i, $wrapperEl: r, wrapperEl: n, progress: l } = s; let o = 0, d = 0; s.isHorizontal() ? o = t ? -e : e : d = e, i.roundLengths && (o = Math.floor(o), d = Math.floor(d)), i.cssMode ? n[s.isHorizontal() ? "scrollLeft" : "scrollTop"] = s.isHorizontal() ? -o : -d : !i.virtualTranslate && r.transform(`translate3d(${o}px, ${d}px, ${0}px)`), s.previousTranslate = s.translate, s.translate = s.isHorizontal() ? o : d; let p; const c = s.maxTranslate() - s.minTranslate(); p = 0 == c ? 0 : (e - s.minTranslate()) / c, p !== l && s.updateProgress(e), s.emit("setTranslate", s.translate, a) }, minTranslate: function () { return -this.snapGrid[0] }, maxTranslate: function () { return -this.snapGrid[this.snapGrid.length - 1] }, translateTo: function (e, a, s, t, i) { void 0 === e && (e = 0), void 0 === a && (a = this.params.speed), void 0 === s && (s = !0), void 0 === t && (t = !0); const r = this, { params: n, wrapperEl: l } = r; if (r.animating && n.preventInteractionOnTransition) return !1; const o = r.minTranslate(), d = r.maxTranslate(); let p; if (p = t && e > o ? o : t && e < d ? d : e, r.updateProgress(p), n.cssMode) { const e = r.isHorizontal(); if (0 === a) l[e ? "scrollLeft" : "scrollTop"] = -p; else { if (!r.support.smoothScroll) return S({ swiper: r, targetPosition: -p, side: e ? "left" : "top" }), !0; l.scrollTo({ [e ? "left" : "top"]: -p, behavior: "smooth" }) } return !0 } return 0 === a ? (r.setTransition(0), r.setTranslate(p), s && (r.emit("beforeTransitionStart", a, i), r.emit("transitionEnd"))) : (r.setTransition(a), r.setTranslate(p), s && (r.emit("beforeTransitionStart", a, i), r.emit("transitionStart")), !r.animating && (r.animating = !0, !r.onTranslateToWrapperTransitionEnd && (r.onTranslateToWrapperTransitionEnd = function (a) { !r || r.destroyed || a.target !== this || (r.$wrapperEl[0].removeEventListener("transitionend", r.onTranslateToWrapperTransitionEnd), r.$wrapperEl[0].removeEventListener("webkitTransitionEnd", r.onTranslateToWrapperTransitionEnd), r.onTranslateToWrapperTransitionEnd = null, delete r.onTranslateToWrapperTransitionEnd, s && r.emit("transitionEnd")) }), r.$wrapperEl[0].addEventListener("transitionend", r.onTranslateToWrapperTransitionEnd), r.$wrapperEl[0].addEventListener("webkitTransitionEnd", r.onTranslateToWrapperTransitionEnd))), !0 } }, transition: { setTransition: function (e, a) { const s = this; s.params.cssMode || s.$wrapperEl.transition(e), s.emit("setTransition", e, a) }, transitionStart: function (e, a) { void 0 === e && (e = !0); const s = this, { params: t } = s; t.cssMode || (t.autoHeight && s.updateAutoHeight(), I({ swiper: s, runCallbacks: e, direction: a, step: "Start" })) }, transitionEnd: function (e, a) { void 0 === e && (e = !0); const s = this, { params: t } = s; s.animating = !1, t.cssMode || (s.setTransition(0), I({ swiper: s, runCallbacks: e, direction: a, step: "End" })) } }, slide: { slideTo: function (e, a, s, t, i) { if (void 0 === e && (e = 0), void 0 === a && (a = this.params.speed), void 0 === s && (s = !0), "number" != typeof e && "string" != typeof e) throw new Error(`The 'index' argument cannot have type other than 'number' or 'string'. [${typeof e}] given.`); if ("string" == typeof e) { const a = parseInt(e, 10), s = isFinite(a); if (!s) throw new Error(`The passed-in 'index' (string) couldn't be converted to 'number'. [${e}] given.`); e = a } const r = this; let n = e; 0 > n && (n = 0); const { params: l, snapGrid: o, slidesGrid: d, previousIndex: p, activeIndex: c, rtlTranslate: m, wrapperEl: u, enabled: h } = r; if (r.animating && l.preventInteractionOnTransition || !h && !t && !i) return !1; const g = Math.min(r.params.slidesPerGroupSkip, n); let f = g + Math.floor((n - g) / r.params.slidesPerGroup); f >= o.length && (f = o.length - 1), (c || l.initialSlide || 0) === (p || 0) && s && r.emit("beforeSlideChangeStart"); const v = -o[f]; if (r.updateProgress(v), l.normalizeSlideIndex) for (let e = 0; e < d.length; e += 1) { const a = -Math.floor(100 * v), s = Math.floor(100 * d[e]), t = Math.floor(100 * d[e + 1]); "undefined" == typeof d[e + 1] ? a >= s && (n = e) : a >= s && a < t - (t - s) / 2 ? n = e : a >= s && a < t && (n = e + 1) } if (r.initialized && n !== c) { if (!r.allowSlideNext && v < r.translate && v < r.minTranslate()) return !1; if (!r.allowSlidePrev && v > r.translate && v > r.maxTranslate() && (c || 0) !== n) return !1 } let w; if (w = n > c ? "next" : n < c ? "prev" : "reset", m && -v === r.translate || !m && v === r.translate) return r.updateActiveIndex(n), l.autoHeight && r.updateAutoHeight(), r.updateSlidesClasses(), "slide" !== l.effect && r.setTranslate(v), "reset" !== w && (r.transitionStart(s, w), r.transitionEnd(s, w)), !1; if (l.cssMode) { const e = r.isHorizontal(), s = m ? v : -v; if (0 === a) { const a = r.virtual && r.params.virtual.enabled; a && (r.wrapperEl.style.scrollSnapType = "none", r._immediateVirtual = !0), u[e ? "scrollLeft" : "scrollTop"] = s, a && requestAnimationFrame(() => { r.wrapperEl.style.scrollSnapType = "", r._swiperImmediateVirtual = !1 }) } else { if (!r.support.smoothScroll) return S({ swiper: r, targetPosition: s, side: e ? "left" : "top" }), !0; u.scrollTo({ [e ? "left" : "top"]: s, behavior: "smooth" }) } return !0 } return r.setTransition(a), r.setTranslate(v), r.updateActiveIndex(n), r.updateSlidesClasses(), r.emit("beforeTransitionStart", a, t), r.transitionStart(s, w), 0 === a ? r.transitionEnd(s, w) : !r.animating && (r.animating = !0, !r.onSlideToWrapperTransitionEnd && (r.onSlideToWrapperTransitionEnd = function (a) { !r || r.destroyed || a.target !== this || (r.$wrapperEl[0].removeEventListener("transitionend", r.onSlideToWrapperTransitionEnd), r.$wrapperEl[0].removeEventListener("webkitTransitionEnd", r.onSlideToWrapperTransitionEnd), r.onSlideToWrapperTransitionEnd = null, delete r.onSlideToWrapperTransitionEnd, r.transitionEnd(s, w)) }), r.$wrapperEl[0].addEventListener("transitionend", r.onSlideToWrapperTransitionEnd), r.$wrapperEl[0].addEventListener("webkitTransitionEnd", r.onSlideToWrapperTransitionEnd)), !0 }, slideToLoop: function (e, a, s, t) { if (void 0 === e && (e = 0), void 0 === a && (a = this.params.speed), void 0 === s && (s = !0), "string" == typeof e) { const a = parseInt(e, 10), s = isFinite(a); if (!s) throw new Error(`The passed-in 'index' (string) couldn't be converted to 'number'. [${e}] given.`); e = a } const i = this; let r = e; return i.params.loop && (r += i.loopedSlides), i.slideTo(r, a, s, t) }, slideNext: function (e, a, s) { void 0 === e && (e = this.params.speed), void 0 === a && (a = !0); const t = this, { animating: i, enabled: r, params: n } = t; if (!r) return t; let l = n.slidesPerGroup; "auto" === n.slidesPerView && 1 === n.slidesPerGroup && n.slidesPerGroupAuto && (l = Math.max(t.slidesPerViewDynamic("current", !0), 1)); const o = t.activeIndex < n.slidesPerGroupSkip ? 1 : l; if (n.loop) { if (i && n.loopPreventsSlide) return !1; t.loopFix(), t._clientLeft = t.$wrapperEl[0].clientLeft } return n.rewind && t.isEnd ? t.slideTo(0, e, a, s) : t.slideTo(t.activeIndex + o, e, a, s) }, slidePrev: function (e, a, s) { function t(e) { return 0 > e ? -Math.floor(Math.abs(e)) : Math.floor(e) } void 0 === e && (e = this.params.speed), void 0 === a && (a = !0); const i = this, { params: r, animating: n, snapGrid: l, slidesGrid: o, rtlTranslate: d, enabled: p } = i; if (!p) return i; if (r.loop) { if (n && r.loopPreventsSlide) return !1; i.loopFix(), i._clientLeft = i.$wrapperEl[0].clientLeft } const c = d ? i.translate : -i.translate, m = t(c), u = l.map(e => t(e)); let h = l[u.indexOf(m) - 1]; if ("undefined" == typeof h && r.cssMode) { let e; l.forEach((a, s) => { m >= a && (e = s) }), "undefined" != typeof e && (h = l[0 < e ? e - 1 : e]) } let g = 0; if ("undefined" != typeof h && (g = o.indexOf(h), 0 > g && (g = i.activeIndex - 1), "auto" === r.slidesPerView && 1 === r.slidesPerGroup && r.slidesPerGroupAuto && (g = g - i.slidesPerViewDynamic("previous", !0) + 1, g = Math.max(g, 0))), r.rewind && i.isBeginning) { const t = i.params.virtual && i.params.virtual.enabled && i.virtual ? i.virtual.slides.length - 1 : i.slides.length - 1; return i.slideTo(t, e, a, s) } return i.slideTo(g, e, a, s) }, slideReset: function (e, a, s) { void 0 === e && (e = this.params.speed), void 0 === a && (a = !0); const t = this; return t.slideTo(t.activeIndex, e, a, s) }, slideToClosest: function (e, a, s, t) { void 0 === e && (e = this.params.speed), void 0 === a && (a = !0), void 0 === t && (t = .5); const i = this; let r = i.activeIndex; const n = Math.min(i.params.slidesPerGroupSkip, r), l = n + Math.floor((r - n) / i.params.slidesPerGroup), o = i.rtlTranslate ? i.translate : -i.translate; if (o >= i.snapGrid[l]) { const e = i.snapGrid[l], a = i.snapGrid[l + 1]; o - e > (a - e) * t && (r += i.params.slidesPerGroup) } else { const e = i.snapGrid[l - 1], a = i.snapGrid[l]; o - e <= (a - e) * t && (r -= i.params.slidesPerGroup) } return r = Math.max(r, 0), r = Math.min(r, i.slidesGrid.length - 1), i.slideTo(r, e, a, s) }, slideToClickedSlide: function () { const e = this, { params: a, $wrapperEl: s } = e, t = "auto" === a.slidesPerView ? e.slidesPerViewDynamic() : a.slidesPerView; let i = e.clickedIndex, r; if (a.loop) { if (e.animating) return; r = parseInt(d(e.clickedSlide).attr("data-swiper-slide-index"), 10), a.centeredSlides ? i < e.loopedSlides - t / 2 || i > e.slides.length - e.loopedSlides + t / 2 ? (e.loopFix(), i = s.children(`.${a.slideClass}[data-swiper-slide-index="${r}"]:not(.${a.slideDuplicateClass})`).eq(0).index(), v(() => { e.slideTo(i) })) : e.slideTo(i) : i > e.slides.length - t ? (e.loopFix(), i = s.children(`.${a.slideClass}[data-swiper-slide-index="${r}"]:not(.${a.slideDuplicateClass})`).eq(0).index(), v(() => { e.slideTo(i) })) : e.slideTo(i) } else e.slideTo(i) } }, loop: { loopCreate: function () { const e = this, a = s(), { params: t, $wrapperEl: i } = e, r = 0 < i.children().length ? d(i.children()[0].parentNode) : i; r.children(`.${t.slideClass}.${t.slideDuplicateClass}`).remove(); let n = r.children(`.${t.slideClass}`); if (t.loopFillGroupWithBlank) { const e = t.slidesPerGroup - n.length % t.slidesPerGroup; if (e !== t.slidesPerGroup) { for (let s = 0; s < e; s += 1) { const e = d(a.createElement("div")).addClass(`${t.slideClass} ${t.slideBlankClass}`); r.append(e) } n = r.children(`.${t.slideClass}`) } } "auto" !== t.slidesPerView || t.loopedSlides || (t.loopedSlides = n.length), e.loopedSlides = Math.ceil(parseFloat(t.loopedSlides || t.slidesPerView, 10)), e.loopedSlides += t.loopAdditionalSlides, e.loopedSlides > n.length && e.params.loopedSlidesLimit && (e.loopedSlides = n.length); const l = [], o = []; n.each((e, a) => { d(e).attr("data-swiper-slide-index", a) }); for (let a = 0; a < e.loopedSlides; a += 1) { const e = a - Math.floor(a / n.length) * n.length; o.push(n.eq(e)[0]), l.unshift(n.eq(n.length - e - 1)[0]) } for (let e = 0; e < o.length; e += 1)r.append(d(o[e].cloneNode(!0)).addClass(t.slideDuplicateClass)); for (let e = l.length - 1; 0 <= e; e -= 1)r.prepend(d(l[e].cloneNode(!0)).addClass(t.slideDuplicateClass)) }, loopFix: function () { const e = this; e.emit("beforeLoopFix"); const { activeIndex: a, slides: s, loopedSlides: t, allowSlidePrev: i, allowSlideNext: r, snapGrid: n, rtlTranslate: l } = e; let o; e.allowSlidePrev = !0, e.allowSlideNext = !0; const d = -n[a], p = d - e.getTranslate(); if (a < t) { o = s.length - 3 * t + a, o += t; const i = e.slideTo(o, 0, !1, !0); i && 0 !== p && e.setTranslate((l ? -e.translate : e.translate) - p) } else if (a >= s.length - t) { o = -s.length + a + t, o += t; const i = e.slideTo(o, 0, !1, !0); i && 0 !== p && e.setTranslate((l ? -e.translate : e.translate) - p) } e.allowSlidePrev = i, e.allowSlideNext = r, e.emit("loopFix") }, loopDestroy: function () { const e = this, { $wrapperEl: a, params: s, slides: t } = e; a.children(`.${s.slideClass}.${s.slideDuplicateClass},.${s.slideClass}.${s.slideBlankClass}`).remove(), t.removeAttr("data-swiper-slide-index") } }, grabCursor: { setGrabCursor: function (e) { const a = this; if (!(a.support.touch || !a.params.simulateTouch || a.params.watchOverflow && a.isLocked || a.params.cssMode)) { const s = "container" === a.params.touchEventsTarget ? a.el : a.wrapperEl; s.style.cursor = "move", s.style.cursor = e ? "grabbing" : "grab" } }, unsetGrabCursor: function () { const e = this; e.support.touch || e.params.watchOverflow && e.isLocked || e.params.cssMode || (e["container" === e.params.touchEventsTarget ? "el" : "wrapperEl"].style.cursor = "") } }, events: { attachEvents: X, detachEvents: function () { const e = this; ce(e, "off") } }, breakpoints: { setBreakpoint: Y, getBreakpoint: function (e, a, s) { if (void 0 === a && (a = "window"), !e || "container" === a && !s) return; let r = !1; const n = t(), l = "window" === a ? n.innerHeight : s.clientHeight, o = Object.keys(e).map(e => { if ("string" == typeof e && 0 === e.indexOf("@")) { const a = parseFloat(e.substr(1)); return { value: l * a, point: e } } return { value: e, point: e } }); o.sort((e, a) => parseInt(e.value, 10) - parseInt(a.value, 10)); for (let t = 0; t < o.length; t += 1) { const { point: e, value: i } = o[t]; "window" === a ? n.matchMedia(`(min-width: ${i}px)`).matches && (r = e) : i <= s.clientWidth && (r = e) } return r || "max" } }, checkOverflow: { checkOverflow: function () { const e = this, { isLocked: a, params: s } = e, { slidesOffsetBefore: t } = s; if (t) { const a = e.slides.length - 1, s = e.slidesGrid[a] + e.slidesSizesGrid[a] + 2 * t; e.isLocked = e.size > s } else e.isLocked = 1 === e.snapGrid.length; !0 === s.allowSlideNext && (e.allowSlideNext = !e.isLocked), !0 === s.allowSlidePrev && (e.allowSlidePrev = !e.isLocked), a && a !== e.isLocked && (e.isEnd = !1), a !== e.isLocked && e.emit(e.isLocked ? "lock" : "unlock") } }, classes: { addClasses: W, removeClasses: function () { const e = this, { $el: a, classNames: s } = e; a.removeClass(s.join(" ")), e.emitContainerClasses() } }, images: { loadImage: function (e, a, s, i, r, n) { function l() { n && n() } const o = t(); let p; const c = d(e).parent("picture")[0]; c || e.complete && r ? l() : a ? (p = new o.Image, p.onload = l, p.onerror = l, i && (p.sizes = i), s && (p.srcset = s), a && (p.src = a)) : l() }, preloadImages: function () { function e() { "undefined" == typeof a || null === a || !a || a.destroyed || (void 0 !== a.imagesLoaded && (a.imagesLoaded += 1), a.imagesLoaded === a.imagesToLoad.length && (a.params.updateOnImagesReady && a.update(), a.emit("imagesReady"))) } const a = this; a.imagesToLoad = a.$el.find("img"); for (let s = 0; s < a.imagesToLoad.length; s += 1) { const t = a.imagesToLoad[s]; a.loadImage(t, t.currentSrc || t.getAttribute("src"), t.srcset || t.getAttribute("srcset"), t.sizes || t.getAttribute("sizes"), !0, e) } } } }, ge = {}; class fe { constructor() { let e, a; for (var s = arguments.length, t = Array(s), i = 0; i < s; i++)t[i] = arguments[i]; if (1 === t.length && t[0].constructor && "Object" === Object.prototype.toString.call(t[0]).slice(8, -1) ? a = t[0] : [e, a] = t, a || (a = {}), a = C({}, a), e && !a.el && (a.el = e), a.el && 1 < d(a.el).length) { const e = []; return d(a.el).each(s => { const t = C({}, a, { el: s }); e.push(new fe(t)) }), e } const r = this; r.__swiper__ = !0, r.support = k(), r.device = M({ userAgent: a.userAgent }), r.browser = L(), r.eventsListeners = {}, r.eventsAnyListeners = [], r.modules = [...r.__modules__], a.modules && Array.isArray(a.modules) && r.modules.push(...a.modules); const n = {}; r.modules.forEach(e => { e({ swiper: r, extendParams: q(a, n), on: r.on.bind(r), once: r.once.bind(r), off: r.off.bind(r), emit: r.emit.bind(r) }) }); const l = C({}, ue, n); return r.params = C({}, l, ge, a), r.originalParams = C({}, r.params), r.passedParams = C({}, a), r.params && r.params.on && Object.keys(r.params.on).forEach(e => { r.on(e, r.params.on[e]) }), r.params && r.params.onAny && r.onAny(r.params.onAny), r.$ = d, Object.assign(r, { enabled: r.params.enabled, el: e, classNames: [], slides: d(), slidesGrid: [], snapGrid: [], slidesSizesGrid: [], isHorizontal() { return "horizontal" === r.params.direction }, isVertical() { return "vertical" === r.params.direction }, activeIndex: 0, realIndex: 0, isBeginning: !0, isEnd: !1, translate: 0, previousTranslate: 0, progress: 0, velocity: 0, animating: !1, allowSlideNext: r.params.allowSlideNext, allowSlidePrev: r.params.allowSlidePrev, touchEvents: function () { const e = ["touchstart", "touchmove", "touchend", "touchcancel"], a = ["pointerdown", "pointermove", "pointerup"]; return r.touchEventsTouch = { start: e[0], move: e[1], end: e[2], cancel: e[3] }, r.touchEventsDesktop = { start: a[0], move: a[1], end: a[2] }, r.support.touch || !r.params.simulateTouch ? r.touchEventsTouch : r.touchEventsDesktop }(), touchEventsData: { isTouched: void 0, isMoved: void 0, allowTouchCallbacks: void 0, touchStartTime: void 0, isScrolling: void 0, currentTranslate: void 0, startTranslate: void 0, allowThresholdMove: void 0, focusableElements: r.params.focusableElements, lastClickTime: w(), clickTimeout: void 0, velocities: [], allowMomentumBounce: void 0, isTouchEvent: void 0, startMoving: void 0 }, allowClick: !0, allowTouchMove: r.params.allowTouchMove, touches: { startX: 0, startY: 0, currentX: 0, currentY: 0, diff: 0 }, imagesToLoad: [], imagesLoaded: 0 }), r.emit("_swiper"), r.params.init && r.init(), r } enable() { const e = this; e.enabled || (e.enabled = !0, e.params.grabCursor && e.setGrabCursor(), e.emit("enable")) } disable() { const e = this; e.enabled && (e.enabled = !1, e.params.grabCursor && e.unsetGrabCursor(), e.emit("disable")) } setProgress(e, a) { const s = this; e = Math.min(Math.max(e, 0), 1); const t = s.minTranslate(), i = s.maxTranslate(), r = (i - t) * e + t; s.translateTo(r, "undefined" == typeof a ? 0 : a), s.updateActiveIndex(), s.updateSlidesClasses() } emitContainerClasses() { const e = this; if (e.params._emitClasses && e.el) { const a = e.el.className.split(" ").filter(a => 0 === a.indexOf("swiper") || 0 === a.indexOf(e.params.containerModifierClass)); e.emit("_containerClasses", a.join(" ")) } } getSlideClasses(e) { const a = this; return a.destroyed ? "" : e.className.split(" ").filter(e => 0 === e.indexOf("swiper-slide") || 0 === e.indexOf(a.params.slideClass)).join(" ") } emitSlidesClasses() { const e = this; if (!e.params._emitClasses || !e.el) return; const a = []; e.slides.each(s => { const t = e.getSlideClasses(s); a.push({ slideEl: s, classNames: t }), e.emit("_slideClass", s, t) }), e.emit("_slideClasses", a) } slidesPerViewDynamic(e, a) { void 0 === e && (e = "current"), void 0 === a && (a = !1); const s = this, { params: t, slides: r, slidesGrid: n, slidesSizesGrid: l, size: o, activeIndex: d } = s; let p = 1; if (t.centeredSlides) { let e = r[d].swiperSlideSize, a; for (let s = d + 1; s < r.length; s += 1)r[s] && !a && (e += r[s].swiperSlideSize, p += 1, e > o && (a = !0)); for (let s = d - 1; 0 <= s; s -= 1)r[s] && !a && (e += r[s].swiperSlideSize, p += 1, e > o && (a = !0)) } else if ("current" === e) for (let e = d + 1; e < r.length; e += 1) { const s = a ? n[e] + l[e] - n[d] < o : n[e] - n[d] < o; s && (p += 1) } else for (let e = d - 1; 0 <= e; e -= 1) { const a = n[d] - n[e] < o; a && (p += 1) } return p } update() { function e() { const e = a.rtlTranslate ? -1 * a.translate : a.translate, s = Math.min(Math.max(e, a.maxTranslate()), a.minTranslate()); a.setTranslate(s), a.updateActiveIndex(), a.updateSlidesClasses() } const a = this; if (!a || a.destroyed) return; const { snapGrid: s, params: t } = a; t.breakpoints && a.setBreakpoint(), a.updateSize(), a.updateSlides(), a.updateProgress(), a.updateSlidesClasses(); let i; a.params.freeMode && a.params.freeMode.enabled ? (e(), a.params.autoHeight && a.updateAutoHeight()) : (i = ("auto" === a.params.slidesPerView || 1 < a.params.slidesPerView) && a.isEnd && !a.params.centeredSlides ? a.slideTo(a.slides.length - 1, 0, !1, !0) : a.slideTo(a.activeIndex, 0, !1, !0), !i && e()), t.watchOverflow && s !== a.snapGrid && a.checkOverflow(), a.emit("update") } changeDirection(e, a) { void 0 === a && (a = !0); const s = this, t = s.params.direction; return (e || (e = "horizontal" === t ? "vertical" : "horizontal"), e === t || "horizontal" !== e && "vertical" !== e) ? s : (s.$el.removeClass(`${s.params.containerModifierClass}${t}`).addClass(`${s.params.containerModifierClass}${e}`), s.emitContainerClasses(), s.params.direction = e, s.slides.each(a => { "vertical" === e ? a.style.width = "" : a.style.height = "" }), s.emit("changeDirection"), a && s.update(), s) } changeLanguageDirection(e) { const a = this; a.rtl && "rtl" === e || !a.rtl && "ltr" === e || (a.rtl = "rtl" === e, a.rtlTranslate = "horizontal" === a.params.direction && a.rtl, a.rtl ? (a.$el.addClass(`${a.params.containerModifierClass}rtl`), a.el.dir = "rtl") : (a.$el.removeClass(`${a.params.containerModifierClass}rtl`), a.el.dir = "ltr"), a.update()) } mount(e) { const a = this; if (a.mounted) return !0; const t = d(e || a.params.el); if (e = t[0], !e) return !1; e.swiper = a; const i = () => `.${(a.params.wrapperClass || "").trim().split(" ").join(".")}`, r = () => { if (e && e.shadowRoot && e.shadowRoot.querySelector) { const a = d(e.shadowRoot.querySelector(i())); return a.children = e => t.children(e), a } return t.children ? t.children(i()) : d(t).children(i()) }; let n = r(); if (0 === n.length && a.params.createElements) { const e = s(), i = e.createElement("div"); n = d(i), i.className = a.params.wrapperClass, t.append(i), t.children(`.${a.params.slideClass}`).each(e => { n.append(e) }) } return Object.assign(a, { $el: t, el: e, $wrapperEl: n, wrapperEl: n[0], mounted: !0, rtl: "rtl" === e.dir.toLowerCase() || "rtl" === t.css("direction"), rtlTranslate: "horizontal" === a.params.direction && ("rtl" === e.dir.toLowerCase() || "rtl" === t.css("direction")), wrongRTL: "-webkit-box" === n.css("display") }), !0 } init(e) { const a = this; if (a.initialized) return a; const s = a.mount(e); return !1 === s ? a : (a.emit("beforeInit"), a.params.breakpoints && a.setBreakpoint(), a.addClasses(), a.params.loop && a.loopCreate(), a.updateSize(), a.updateSlides(), a.params.watchOverflow && a.checkOverflow(), a.params.grabCursor && a.enabled && a.setGrabCursor(), a.params.preloadImages && a.preloadImages(), a.params.loop ? a.slideTo(a.params.initialSlide + a.loopedSlides, 0, a.params.runCallbacksOnInit, !1, !0) : a.slideTo(a.params.initialSlide, 0, a.params.runCallbacksOnInit, !1, !0), a.attachEvents(), a.initialized = !0, a.emit("init"), a.emit("afterInit"), a) } destroy(e, a) { void 0 === e && (e = !0), void 0 === a && (a = !0); const s = this, { params: t, $el: i, $wrapperEl: r, slides: n } = s; return "undefined" == typeof s.params || s.destroyed ? null : (s.emit("beforeDestroy"), s.initialized = !1, s.detachEvents(), t.loop && s.loopDestroy(), a && (s.removeClasses(), i.removeAttr("style"), r.removeAttr("style"), n && n.length && n.removeClass([t.slideVisibleClass, t.slideActiveClass, t.slideNextClass, t.slidePrevClass].join(" ")).removeAttr("style").removeAttr("data-swiper-slide-index")), s.emit("destroy"), Object.keys(s.eventsListeners).forEach(e => { s.off(e) }), !1 !== e && (s.$el[0].swiper = null, f(s)), s.destroyed = !0, null) } static extendDefaults(e) { C(ge, e) } static get extendedDefaults() { return ge } static get defaults() { return ue } static installModule(e) { fe.prototype.__modules__ || (fe.prototype.__modules__ = []); const a = fe.prototype.__modules__; "function" == typeof e && 0 > a.indexOf(e) && a.push(e) } static use(e) { return Array.isArray(e) ? (e.forEach(e => fe.installModule(e)), fe) : (fe.installModule(e), fe) } } Object.keys(he).forEach(e => { Object.keys(he[e]).forEach(a => { fe.prototype[a] = he[e][a] }) }), fe.use([function (e) { let { swiper: a, on: s, emit: i } = e; const r = t(); let n = null, l = null; const o = () => { a && !a.destroyed && a.initialized && (i("beforeResize"), i("resize")) }, d = () => { a && !a.destroyed && a.initialized && (n = new ResizeObserver(e => { l = r.requestAnimationFrame(() => { const { width: s, height: t } = a; let i = s, r = t; e.forEach(e => { let { contentBoxSize: s, contentRect: t, target: n } = e; n && n !== a.el || (i = t ? t.width : (s[0] || s).inlineSize, r = t ? t.height : (s[0] || s).blockSize) }), (i !== s || r !== t) && o() }) }), n.observe(a.el)) }, p = () => { l && r.cancelAnimationFrame(l), n && n.unobserve && a.el && (n.unobserve(a.el), n = null) }, c = () => { a && !a.destroyed && a.initialized && i("orientationchange") }; s("init", () => a.params.resizeObserver && "undefined" != typeof r.ResizeObserver ? void d() : void (r.addEventListener("resize", o), r.addEventListener("orientationchange", c))), s("destroy", () => { p(), r.removeEventListener("resize", o), r.removeEventListener("orientationchange", c) }) }, function (e) { let { swiper: a, extendParams: s, on: i, emit: r } = e; const n = [], l = t(), o = function (e, a) { void 0 === a && (a = {}); const s = l.MutationObserver || l.WebkitMutationObserver, t = new s(e => { if (1 === e.length) return void r("observerUpdate", e[0]); const a = function () { r("observerUpdate", e[0]) }; l.requestAnimationFrame ? l.requestAnimationFrame(a) : l.setTimeout(a, 0) }); t.observe(e, { attributes: "undefined" == typeof a.attributes || a.attributes, childList: "undefined" == typeof a.childList || a.childList, characterData: "undefined" == typeof a.characterData || a.characterData }), n.push(t) }; s({ observer: !1, observeParents: !1, observeSlideChildren: !1 }), i("init", () => { if (a.params.observer) { if (a.params.observeParents) { const e = a.$el.parents(); for (let a = 0; a < e.length; a += 1)o(e[a]) } o(a.$el[0], { childList: a.params.observeSlideChildren }), o(a.$wrapperEl[0], { attributes: !1 }) } }), i("destroy", () => { n.forEach(e => { e.disconnect() }), n.splice(0, n.length) }) }]); return fe.use([function (e) { function a(e, a) { const s = r.params.virtual; if (s.cache && r.virtual.cache[a]) return r.virtual.cache[a]; const t = s.renderSlide ? d(s.renderSlide.call(r, e, a)) : d(`<div class="${r.params.slideClass}" data-swiper-slide-index="${a}">${e}</div>`); return t.attr("data-swiper-slide-index") || t.attr("data-swiper-slide-index", a), s.cache && (r.virtual.cache[a] = t), t } function s(e) { function s() { r.updateSlides(), r.updateProgress(), r.updateSlidesClasses(), r.lazy && r.params.lazy.enabled && r.lazy.load(), i("virtualUpdate") } const { slidesPerView: t, slidesPerGroup: n, centeredSlides: l } = r.params, { addSlidesBefore: o, addSlidesAfter: d } = r.params.virtual, { from: p, to: c, slides: m, slidesGrid: u, offset: h } = r.virtual; r.params.cssMode || r.updateActiveIndex(); const g = r.activeIndex || 0; let f = r.rtlTranslate ? "right" : r.isHorizontal() ? "left" : "top"; let v, w; l ? (v = Math.floor(t / 2) + n + d, w = Math.floor(t / 2) + n + o) : (v = t + (n - 1) + d, w = n + o); const b = Math.max((g || 0) - w, 0), y = Math.min((g || 0) + v, m.length - 1), x = (r.slidesGrid[b] || 0) - (r.slidesGrid[0] || 0); if (Object.assign(r.virtual, { from: b, to: y, offset: x, slidesGrid: r.slidesGrid }), p === b && c === y && !e) return r.slidesGrid !== u && x !== h && r.slides.css(f, `${x}px`), r.updateProgress(), void i("virtualUpdate"); if (r.params.virtual.renderExternal) return r.params.virtual.renderExternal.call(r, { offset: x, from: b, to: y, slides: function () { const e = []; for (let a = b; a <= y; a += 1)e.push(m[a]); return e }() }), void (r.params.virtual.renderExternalUpdate ? s() : i("virtualUpdate")); const E = [], C = []; if (e) r.$wrapperEl.find(`.${r.params.slideClass}`).remove(); else for (let e = p; e <= c; e += 1)(e < b || e > y) && r.$wrapperEl.find(`.${r.params.slideClass}[data-swiper-slide-index="${e}"]`).remove(); for (let a = 0; a < m.length; a += 1)a >= b && a <= y && ("undefined" == typeof c || e ? C.push(a) : (a > c && C.push(a), a < p && E.push(a))); C.forEach(e => { r.$wrapperEl.append(a(m[e], e)) }), E.sort((e, a) => a - e).forEach(e => { r.$wrapperEl.prepend(a(m[e], e)) }), r.$wrapperEl.children(".swiper-slide").css(f, `${x}px`), s() } function t(e) { if ("object" == typeof e && "length" in e) for (let a = 0; a < e.length; a += 1)e[a] && r.virtual.slides.push(e[a]); else r.virtual.slides.push(e); s(!0) } let { swiper: r, extendParams: n, on: l, emit: i } = e; n({ virtual: { enabled: !1, slides: [], cache: !0, renderSlide: null, renderExternal: null, renderExternalUpdate: !0, addSlidesBefore: 0, addSlidesAfter: 0 } }); let o; r.virtual = { cache: {}, from: void 0, to: void 0, slides: [], offset: 0, slidesGrid: [] }, l("beforeInit", () => { r.params.virtual.enabled && (r.virtual.slides = r.params.virtual.slides, r.classNames.push(`${r.params.containerModifierClass}virtual`), r.params.watchSlidesProgress = !0, r.originalParams.watchSlidesProgress = !0, !r.params.initialSlide && s()) }), l("setTranslate", () => { r.params.virtual.enabled && (r.params.cssMode && !r._immediateVirtual ? (clearTimeout(o), o = setTimeout(() => { s() }, 100)) : s()) }), l("init update resize", () => { !r.params.virtual.enabled || r.params.cssMode && T(r.wrapperEl, "--swiper-virtual-size", `${r.virtualSize}px`) }), Object.assign(r.virtual, { appendSlide: t, prependSlide: function (e) { const a = r.activeIndex; let t = a + 1, i = 1; if (Array.isArray(e)) { for (let a = 0; a < e.length; a += 1)e[a] && r.virtual.slides.unshift(e[a]); t = a + e.length, i = e.length } else r.virtual.slides.unshift(e); if (r.params.virtual.cache) { const e = r.virtual.cache, a = {}; Object.keys(e).forEach(s => { const t = e[s], r = t.attr("data-swiper-slide-index"); r && t.attr("data-swiper-slide-index", parseInt(r, 10) + i), a[parseInt(s, 10) + i] = t }), r.virtual.cache = a } s(!0), r.slideTo(t, 0) }, removeSlide: function (e) { if ("undefined" == typeof e || null === e) return; let a = r.activeIndex; if (Array.isArray(e)) for (let s = e.length - 1; 0 <= s; s -= 1)r.virtual.slides.splice(e[s], 1), r.params.virtual.cache && delete r.virtual.cache[e[s]], e[s] < a && (a -= 1), a = Math.max(a, 0); else r.virtual.slides.splice(e, 1), r.params.virtual.cache && delete r.virtual.cache[e], e < a && (a -= 1), a = Math.max(a, 0); s(!0), r.slideTo(a, 0) }, removeAllSlides: function () { r.virtual.slides = [], r.params.virtual.cache && (r.virtual.cache = {}), s(!0), r.slideTo(0, 0) }, update: s }) }, function (e) { function a(a) { if (!n.enabled) return; const { rtlTranslate: s } = n; let t = a; t.originalEvent && (t = t.originalEvent); const i = t.keyCode || t.charCode, r = n.params.keyboard.pageUpDown, l = r && 33 === i, o = r && 34 === i, d = 37 === i, u = 39 === i, h = 38 === i, g = 40 === i; if (!n.allowSlideNext && (n.isHorizontal() && u || n.isVertical() && g || o)) return !1; if (!n.allowSlidePrev && (n.isHorizontal() && d || n.isVertical() && h || l)) return !1; if (!(t.shiftKey || t.altKey || t.ctrlKey || t.metaKey) && !(c.activeElement && c.activeElement.nodeName && ("input" === c.activeElement.nodeName.toLowerCase() || "textarea" === c.activeElement.nodeName.toLowerCase()))) { if (n.params.keyboard.onlyInViewport && (l || o || d || u || h || g)) { let e = !1; if (0 < n.$el.parents(`.${n.params.slideClass}`).length && 0 === n.$el.parents(`.${n.params.slideActiveClass}`).length) return; const a = n.$el, t = a[0].clientWidth, i = a[0].clientHeight, r = m.innerWidth, l = m.innerHeight, o = n.$el.offset(); s && (o.left -= n.$el[0].scrollLeft); const d = [[o.left, o.top], [o.left + t, o.top], [o.left, o.top + i], [o.left + t, o.top + i]]; for (let a = 0; a < d.length; a += 1) { const s = d[a]; if (0 <= s[0] && s[0] <= r && 0 <= s[1] && s[1] <= l) { if (0 === s[0] && 0 === s[1]) continue; e = !0 } } if (!e) return } return n.isHorizontal() ? ((l || o || d || u) && (t.preventDefault ? t.preventDefault() : t.returnValue = !1), ((o || u) && !s || (l || d) && s) && n.slideNext(), ((l || d) && !s || (o || u) && s) && n.slidePrev()) : ((l || o || h || g) && (t.preventDefault ? t.preventDefault() : t.returnValue = !1), (o || g) && n.slideNext(), (l || h) && n.slidePrev()), void p("keyPress", i) } } function i() { n.keyboard.enabled || (d(c).on("keydown", a), n.keyboard.enabled = !0) } function r() { n.keyboard.enabled && (d(c).off("keydown", a), n.keyboard.enabled = !1) } let { swiper: n, extendParams: l, on: o, emit: p } = e; const c = s(), m = t(); n.keyboard = { enabled: !1 }, l({ keyboard: { enabled: !1, onlyInViewport: !0, pageUpDown: !0 } }), o("init", () => { n.params.keyboard.enabled && i() }), o("destroy", () => { n.keyboard.enabled && r() }), Object.assign(n.keyboard, { enable: i, disable: r }) }, function (e) { function a(a) { const e = 40, s = 800; let t = 0, i = 0, r = 0, n = 0; return "detail" in a && (i = a.detail), "wheelDelta" in a && (i = -a.wheelDelta / 120), "wheelDeltaY" in a && (i = -a.wheelDeltaY / 120), "wheelDeltaX" in a && (t = -a.wheelDeltaX / 120), "axis" in a && a.axis === a.HORIZONTAL_AXIS && (t = i, i = 0), r = 10 * t, n = 10 * i, "deltaY" in a && (n = a.deltaY), "deltaX" in a && (r = a.deltaX), a.shiftKey && !r && (r = n, n = 0), (r || n) && a.deltaMode && (1 === a.deltaMode ? (r *= e, n *= e) : (r *= s, n *= s)), r && !t && (t = 1 > r ? -1 : 1), n && !i && (i = 1 > n ? -1 : 1), { spinX: t, spinY: i, pixelX: r, pixelY: n } } function s() { m.enabled && (m.mouseEntered = !0) } function i() { m.enabled && (m.mouseEntered = !1) } function r(e) { return !(m.params.mousewheel.thresholdDelta && e.delta < m.params.mousewheel.thresholdDelta) && !(m.params.mousewheel.thresholdTime && w() - b < m.params.mousewheel.thresholdTime) && (!!(6 <= e.delta && 60 > w() - b) || (0 > e.direction ? (!m.isEnd || m.params.loop) && !m.animating && (m.slideNext(), g("scroll", e.raw)) : (!m.isBeginning || m.params.loop) && !m.animating && (m.slidePrev(), g("scroll", e.raw)), b = new f.Date().getTime(), !1)) } function n(e) { const a = m.params.mousewheel; if (0 > e.direction) { if (m.isEnd && !m.params.loop && a.releaseOnEdges) return !0; } else if (m.isBeginning && !m.params.loop && a.releaseOnEdges) return !0; return !1 } function l(s) { let t = s, i = !0; if (!m.enabled) return; const l = m.params.mousewheel; m.params.cssMode && t.preventDefault(); let o = m.$el; if ("container" !== m.params.mousewheel.eventsTarget && (o = d(m.params.mousewheel.eventsTarget)), !m.mouseEntered && !o[0].contains(t.target) && !l.releaseOnEdges) return !0; t.originalEvent && (t = t.originalEvent); let p = 0; const c = m.rtlTranslate ? -1 : 1, u = a(t); if (!l.forceToAxis) p = Math.abs(u.pixelX) > Math.abs(u.pixelY) ? -u.pixelX * c : -u.pixelY; else if (m.isHorizontal()) { if (Math.abs(u.pixelX) > Math.abs(u.pixelY)) p = -u.pixelX * c; else return !0; } else if (Math.abs(u.pixelY) > Math.abs(u.pixelX)) p = -u.pixelY; else return !0; if (0 == p) return !0; l.invert && (p = -p); let h = m.getTranslate() + p * l.sensitivity; if (h >= m.minTranslate() && (h = m.minTranslate()), h <= m.maxTranslate() && (h = m.maxTranslate()), i = !!m.params.loop || h !== m.minTranslate() && h !== m.maxTranslate(), i && m.params.nested && t.stopPropagation(), !m.params.freeMode || !m.params.freeMode.enabled) { const e = { time: w(), delta: Math.abs(p), direction: Math.sign(p), raw: s }; 2 <= E.length && E.shift(); const a = E.length ? E[E.length - 1] : void 0; if (E.push(e), a ? (e.direction !== a.direction || e.delta > a.delta || e.time > a.time + 150) && r(e) : r(e), n(e)) return !0 } else { const e = { time: w(), delta: Math.abs(p), direction: Math.sign(p) }, a = x && e.time < x.time + 500 && e.delta <= x.delta && e.direction === x.direction; if (!a) { x = void 0, m.params.loop && m.loopFix(); let s = m.getTranslate() + p * l.sensitivity; const i = m.isBeginning, r = m.isEnd; if (s >= m.minTranslate() && (s = m.minTranslate()), s <= m.maxTranslate() && (s = m.maxTranslate()), m.setTransition(0), m.setTranslate(s), m.updateProgress(), m.updateActiveIndex(), m.updateSlidesClasses(), (!i && m.isBeginning || !r && m.isEnd) && m.updateSlidesClasses(), m.params.freeMode.sticky) { clearTimeout(y), y = void 0, 15 <= E.length && E.shift(); const a = E.length ? E[E.length - 1] : void 0, s = E[0]; if (E.push(e), a && (e.delta > a.delta || e.direction !== a.direction)) E.splice(0); else if (15 <= E.length && 500 > e.time - s.time && 1 <= s.delta - e.delta && 6 >= e.delta) { const a = 0 < p ? .8 : .2; x = e, E.splice(0), y = v(() => { m.slideToClosest(m.params.speed, !0, void 0, a) }, 0) } y || (y = v(() => { x = e, E.splice(0), m.slideToClosest(m.params.speed, !0, void 0, .5) }, 500)) } if (a || g("scroll", t), m.params.autoplay && m.params.autoplayDisableOnInteraction && m.autoplay.stop(), s === m.minTranslate() || s === m.maxTranslate()) return !0 } } return t.preventDefault ? t.preventDefault() : t.returnValue = !1, !1 } function o(e) { let a = m.$el; "container" !== m.params.mousewheel.eventsTarget && (a = d(m.params.mousewheel.eventsTarget)), a[e]("mouseenter", s), a[e]("mouseleave", i), a[e]("wheel", l) } function p() { return m.params.cssMode ? (m.wrapperEl.removeEventListener("wheel", l), !0) : !m.mousewheel.enabled && (o("on"), m.mousewheel.enabled = !0, !0) } function c() { return m.params.cssMode ? (m.wrapperEl.addEventListener(event, l), !0) : !!m.mousewheel.enabled && (o("off"), m.mousewheel.enabled = !1, !0) } let { swiper: m, extendParams: u, on: h, emit: g } = e; const f = t(); u({ mousewheel: { enabled: !1, releaseOnEdges: !1, invert: !1, forceToAxis: !1, sensitivity: 1, eventsTarget: "container", thresholdDelta: null, thresholdTime: null } }), m.mousewheel = { enabled: !1 }; let b = w(), y, x; const E = []; h("init", () => { !m.params.mousewheel.enabled && m.params.cssMode && c(), m.params.mousewheel.enabled && p() }), h("destroy", () => { m.params.cssMode && p(), m.mousewheel.enabled && c() }), Object.assign(m.mousewheel, { enable: p, disable: c }) }, function (e) { function a(e) { let a; return e && (a = d(e), o.params.uniqueNavElements && "string" == typeof e && 1 < a.length && 1 === o.$el.find(e).length && (a = o.$el.find(e))), a } function s(e, a) { const s = o.params.navigation; e && 0 < e.length && (e[a ? "addClass" : "removeClass"](s.disabledClass), e[0] && "BUTTON" === e[0].tagName && (e[0].disabled = a), o.params.watchOverflow && o.enabled && e[o.isLocked ? "addClass" : "removeClass"](s.lockClass)) } function t() { if (!o.params.loop) { const { $nextEl: e, $prevEl: a } = o.navigation; s(a, o.isBeginning && !o.params.rewind), s(e, o.isEnd && !o.params.rewind) } } function i(a) { a.preventDefault(), (!o.isBeginning || o.params.loop || o.params.rewind) && (o.slidePrev(), m("navigationPrev")) } function r(a) { a.preventDefault(), (!o.isEnd || o.params.loop || o.params.rewind) && (o.slideNext(), m("navigationNext")) } function n() { const e = o.params.navigation; if (o.params.navigation = V(o, o.originalParams.navigation, o.params.navigation, { nextEl: "swiper-button-next", prevEl: "swiper-button-prev" }), !(e.nextEl || e.prevEl)) return; const s = a(e.nextEl), t = a(e.prevEl); s && 0 < s.length && s.on("click", r), t && 0 < t.length && t.on("click", i), Object.assign(o.navigation, { $nextEl: s, nextEl: s && s[0], $prevEl: t, prevEl: t && t[0] }), o.enabled || (s && s.addClass(e.lockClass), t && t.addClass(e.lockClass)) } function l() { const { $nextEl: e, $prevEl: a } = o.navigation; e && e.length && (e.off("click", r), e.removeClass(o.params.navigation.disabledClass)), a && a.length && (a.off("click", i), a.removeClass(o.params.navigation.disabledClass)) } let { swiper: o, extendParams: p, on: c, emit: m } = e; p({ navigation: { nextEl: null, prevEl: null, hideOnClick: !1, disabledClass: "swiper-button-disabled", hiddenClass: "swiper-button-hidden", lockClass: "swiper-button-lock", navigationDisabledClass: "swiper-navigation-disabled" } }), o.navigation = { nextEl: null, $nextEl: null, prevEl: null, $prevEl: null }, c("init", () => { !1 === o.params.navigation.enabled ? u() : (n(), t()) }), c("toEdge fromEdge lock unlock", () => { t() }), c("destroy", () => { l() }), c("enable disable", () => { const { $nextEl: e, $prevEl: a } = o.navigation; e && e[o.enabled ? "removeClass" : "addClass"](o.params.navigation.lockClass), a && a[o.enabled ? "removeClass" : "addClass"](o.params.navigation.lockClass) }), c("click", (a, s) => { const { $nextEl: e, $prevEl: t } = o.navigation, i = s.target; if (o.params.navigation.hideOnClick && !d(i).is(t) && !d(i).is(e)) { if (o.pagination && o.params.pagination && o.params.pagination.clickable && (o.pagination.el === i || o.pagination.el.contains(i))) return; let a; e ? a = e.hasClass(o.params.navigation.hiddenClass) : t && (a = t.hasClass(o.params.navigation.hiddenClass)), !0 === a ? m("navigationShow") : m("navigationHide"), e && e.toggleClass(o.params.navigation.hiddenClass), t && t.toggleClass(o.params.navigation.hiddenClass) } }); const u = () => { o.$el.addClass(o.params.navigation.navigationDisabledClass), l() }; Object.assign(o.navigation, { enable: () => { o.$el.removeClass(o.params.navigation.navigationDisabledClass), n(), t() }, disable: u, update: t, init: n, destroy: l }) }, function (e) { function a() { return !l.params.pagination.el || !l.pagination.el || !l.pagination.$el || 0 === l.pagination.$el.length } function s(e, a) { const { bulletActiveClass: s } = l.params.pagination; e[a]().addClass(`${s}-${a}`)[a]().addClass(`${s}-${a}-${a}`) } function t() { const e = l.rtl, t = l.params.pagination; if (a()) return; const i = l.virtual && l.params.virtual.enabled ? l.virtual.slides.length : l.slides.length, r = l.pagination.$el; let n; const o = l.params.loop ? Math.ceil((i - 2 * l.loopedSlides) / l.params.slidesPerGroup) : l.snapGrid.length; if (l.params.loop ? (n = Math.ceil((l.activeIndex - l.loopedSlides) / l.params.slidesPerGroup), n > i - 1 - 2 * l.loopedSlides && (n -= i - 2 * l.loopedSlides), n > o - 1 && (n -= o), 0 > n && "bullets" !== l.params.paginationType && (n = o + n)) : "undefined" == typeof l.snapIndex ? n = l.activeIndex || 0 : n = l.snapIndex, "bullets" === t.type && l.pagination.bullets && 0 < l.pagination.bullets.length) { const a = l.pagination.bullets; let o, p, c; if (t.dynamicBullets && (u = a.eq(0)[l.isHorizontal() ? "outerWidth" : "outerHeight"](!0), r.css(l.isHorizontal() ? "width" : "height", `${u * (t.dynamicMainBullets + 4)}px`), 1 < t.dynamicMainBullets && void 0 !== l.previousIndex && (m += n - (l.previousIndex - l.loopedSlides || 0), m > t.dynamicMainBullets - 1 ? m = t.dynamicMainBullets - 1 : 0 > m && (m = 0)), o = Math.max(n - m, 0), p = o + (Math.min(a.length, t.dynamicMainBullets) - 1), c = (p + o) / 2), a.removeClass(["", "-next", "-next-next", "-prev", "-prev-prev", "-main"].map(e => `${t.bulletActiveClass}${e}`).join(" ")), 1 < r.length) a.each(e => { const a = d(e), i = a.index(); i === n && a.addClass(t.bulletActiveClass), t.dynamicBullets && (i >= o && i <= p && a.addClass(`${t.bulletActiveClass}-main`), i === o && s(a, "prev"), i === p && s(a, "next")) }); else { const e = a.eq(n), i = e.index(); if (e.addClass(t.bulletActiveClass), t.dynamicBullets) { const e = a.eq(o), r = a.eq(p); for (let e = o; e <= p; e += 1)a.eq(e).addClass(`${t.bulletActiveClass}-main`); if (!l.params.loop) s(e, "prev"), s(r, "next"); else if (i >= a.length) { for (let e = t.dynamicMainBullets; 0 <= e; e -= 1)a.eq(a.length - e).addClass(`${t.bulletActiveClass}-main`); a.eq(a.length - t.dynamicMainBullets - 1).addClass(`${t.bulletActiveClass}-prev`) } else s(e, "prev"), s(r, "next") } } if (t.dynamicBullets) { const s = Math.min(a.length, t.dynamicMainBullets + 4), i = (u * s - u) / 2 - c * u, r = e ? "right" : "left"; a.css(l.isHorizontal() ? r : "top", `${i}px`) } } if ("fraction" === t.type && (r.find(F(t.currentClass)).text(t.formatFractionCurrent(n + 1)), r.find(F(t.totalClass)).text(t.formatFractionTotal(o))), "progressbar" === t.type) { let e = t.progressbarOpposite ? l.isHorizontal() ? "vertical" : "horizontal" : l.isHorizontal() ? "horizontal" : "vertical"; const a = (n + 1) / o; let s = 1, i = 1; "horizontal" === e ? s = a : i = a, r.find(F(t.progressbarFillClass)).transform(`translate3d(0,0,0) scaleX(${s}) scaleY(${i})`).transition(l.params.speed) } "custom" === t.type && t.renderCustom ? (r.html(t.renderCustom(l, n + 1, o)), c("paginationRender", r[0])) : c("paginationUpdate", r[0]), l.params.watchOverflow && l.enabled && r[l.isLocked ? "addClass" : "removeClass"](t.lockClass) } function i() { const e = l.params.pagination; if (a()) return; const s = l.virtual && l.params.virtual.enabled ? l.virtual.slides.length : l.slides.length, t = l.pagination.$el; let r = ""; if ("bullets" === e.type) { let a = l.params.loop ? Math.ceil((s - 2 * l.loopedSlides) / l.params.slidesPerGroup) : l.snapGrid.length; l.params.freeMode && l.params.freeMode.enabled && !l.params.loop && a > s && (a = s); for (let s = 0; s < a; s += 1)r += e.renderBullet ? e.renderBullet.call(l, s, e.bulletClass) : `<${e.bulletElement} class="${e.bulletClass}"></${e.bulletElement}>`; t.html(r), l.pagination.bullets = t.find(F(e.bulletClass)) } "fraction" === e.type && (r = e.renderFraction ? e.renderFraction.call(l, e.currentClass, e.totalClass) : `<span class="${e.currentClass}"></span>` + " / " + `<span class="${e.totalClass}"></span>`, t.html(r)), "progressbar" === e.type && (r = e.renderProgressbar ? e.renderProgressbar.call(l, e.progressbarFillClass) : `<span class="${e.progressbarFillClass}"></span>`, t.html(r)), "custom" !== e.type && c("paginationRender", l.pagination.$el[0]) } function r() { l.params.pagination = V(l, l.originalParams.pagination, l.params.pagination, { el: "swiper-pagination" }); const e = l.params.pagination; if (!e.el) return; let a = d(e.el); 0 === a.length || (l.params.uniqueNavElements && "string" == typeof e.el && 1 < a.length && (a = l.$el.find(e.el), 1 < a.length && (a = a.filter(e => d(e).parents(".swiper")[0] === l.el))), "bullets" === e.type && e.clickable && a.addClass(e.clickableClass), a.addClass(e.modifierClass + e.type), a.addClass(l.isHorizontal() ? e.horizontalClass : e.verticalClass), "bullets" === e.type && e.dynamicBullets && (a.addClass(`${e.modifierClass}${e.type}-dynamic`), m = 0, 1 > e.dynamicMainBullets && (e.dynamicMainBullets = 1)), "progressbar" === e.type && e.progressbarOpposite && a.addClass(e.progressbarOppositeClass), e.clickable && a.on("click", F(e.bulletClass), function (a) { a.preventDefault(); let e = d(this).index() * l.params.slidesPerGroup; l.params.loop && (e += l.loopedSlides), l.slideTo(e) }), Object.assign(l.pagination, { $el: a, el: a[0] }), !l.enabled && a.addClass(e.lockClass)) } function n() { const e = l.params.pagination; if (!a()) { const a = l.pagination.$el; a.removeClass(e.hiddenClass), a.removeClass(e.modifierClass + e.type), a.removeClass(l.isHorizontal() ? e.horizontalClass : e.verticalClass), l.pagination.bullets && l.pagination.bullets.removeClass && l.pagination.bullets.removeClass(e.bulletActiveClass), e.clickable && a.off("click", F(e.bulletClass)) } } let { swiper: l, extendParams: o, on: p, emit: c } = e; o({ pagination: { el: null, bulletElement: "span", clickable: !1, hideOnClick: !1, renderBullet: null, renderProgressbar: null, renderFraction: null, renderCustom: null, progressbarOpposite: !1, type: "bullets", dynamicBullets: !1, dynamicMainBullets: 1, formatFractionCurrent: e => e, formatFractionTotal: e => e, bulletClass: `${"swiper-pagination"}-bullet`, bulletActiveClass: `${"swiper-pagination"}-bullet-active`, modifierClass: `${"swiper-pagination"}-`, currentClass: `${"swiper-pagination"}-current`, totalClass: `${"swiper-pagination"}-total`, hiddenClass: `${"swiper-pagination"}-hidden`, progressbarFillClass: `${"swiper-pagination"}-progressbar-fill`, progressbarOppositeClass: `${"swiper-pagination"}-progressbar-opposite`, clickableClass: `${"swiper-pagination"}-clickable`, lockClass: `${"swiper-pagination"}-lock`, horizontalClass: `${"swiper-pagination"}-horizontal`, verticalClass: `${"swiper-pagination"}-vertical`, paginationDisabledClass: `${"swiper-pagination"}-disabled` } }), l.pagination = { el: null, $el: null, bullets: [] }; let m = 0, u; p("init", () => { !1 === l.params.pagination.enabled ? h() : (r(), i(), t()) }), p("activeIndexChange", () => { l.params.loop ? t() : "undefined" == typeof l.snapIndex && t() }), p("snapIndexChange", () => { l.params.loop || t() }), p("slidesLengthChange", () => { l.params.loop && (i(), t()) }), p("snapGridLengthChange", () => { l.params.loop || (i(), t()) }), p("destroy", () => { n() }), p("enable disable", () => { const { $el: e } = l.pagination; e && e[l.enabled ? "removeClass" : "addClass"](l.params.pagination.lockClass) }), p("lock unlock", () => { t() }), p("click", (a, s) => { const e = s.target, { $el: t } = l.pagination; if (l.params.pagination.el && l.params.pagination.hideOnClick && t && 0 < t.length && !d(e).hasClass(l.params.pagination.bulletClass)) { if (l.navigation && (l.navigation.nextEl && e === l.navigation.nextEl || l.navigation.prevEl && e === l.navigation.prevEl)) return; const a = t.hasClass(l.params.pagination.hiddenClass); !0 === a ? c("paginationShow") : c("paginationHide"), t.toggleClass(l.params.pagination.hiddenClass) } }); const h = () => { l.$el.addClass(l.params.pagination.paginationDisabledClass), l.pagination.$el && l.pagination.$el.addClass(l.params.pagination.paginationDisabledClass), n() }; Object.assign(l.pagination, { enable: () => { l.$el.removeClass(l.params.pagination.paginationDisabledClass), l.pagination.$el && l.pagination.$el.removeClass(l.params.pagination.paginationDisabledClass), r(), i(), t() }, disable: h, render: i, update: t, init: r, destroy: n }) }, function (e) { function a() { if (!f.params.scrollbar.el || !f.scrollbar.el) return; const { scrollbar: e, rtlTranslate: a, progress: s } = f, { $dragEl: t, $el: i } = e, r = f.params.scrollbar; let n = P, l = (k - P) * s; a ? (l = -l, 0 < l ? (n = P - l, l = 0) : -l + P > k && (n = k + l)) : 0 > l ? (n = P + l, l = 0) : l + P > k && (n = k - l), f.isHorizontal() ? (t.transform(`translate3d(${l}px, 0, 0)`), t[0].style.width = `${n}px`) : (t.transform(`translate3d(0px, ${l}px, 0)`), t[0].style.height = `${n}px`), r.hide && (clearTimeout(C), i[0].style.opacity = 1, C = setTimeout(() => { i[0].style.opacity = 0, i.transition(400) }, 1e3)) } function t(e) { f.params.scrollbar.el && f.scrollbar.el && f.scrollbar.$dragEl.transition(e) } function i() { if (!f.params.scrollbar.el || !f.scrollbar.el) return; const { scrollbar: e } = f, { $dragEl: a, $el: s } = e; a[0].style.width = "", a[0].style.height = "", k = f.isHorizontal() ? s[0].offsetWidth : s[0].offsetHeight, $ = f.size / (f.virtualSize + f.params.slidesOffsetBefore - (f.params.centeredSlides ? f.snapGrid[0] : 0)), P = "auto" === f.params.scrollbar.dragSize ? k * $ : parseInt(f.params.scrollbar.dragSize, 10), f.isHorizontal() ? a[0].style.width = `${P}px` : a[0].style.height = `${P}px`, s[0].style.display = 1 <= $ ? "none" : "", f.params.scrollbar.hide && (s[0].style.opacity = 0), f.params.watchOverflow && f.enabled && e.$el[f.isLocked ? "addClass" : "removeClass"](f.params.scrollbar.lockClass) } function r(a) { return f.isHorizontal() ? "touchstart" === a.type || "touchmove" === a.type ? a.targetTouches[0].clientX : a.clientX : "touchstart" === a.type || "touchmove" === a.type ? a.targetTouches[0].clientY : a.clientY } function n(a) { const { scrollbar: e, rtlTranslate: s } = f, { $el: t } = e; let i; i = (r(a) - t.offset()[f.isHorizontal() ? "left" : "top"] - (null === S ? P / 2 : S)) / (k - P), i = Math.max(Math.min(i, 1), 0), s && (i = 1 - i); const n = f.minTranslate() + (f.maxTranslate() - f.minTranslate()) * i; f.updateProgress(n), f.setTranslate(n), f.updateActiveIndex(), f.updateSlidesClasses() } function l(a) { const e = f.params.scrollbar, { scrollbar: s, $wrapperEl: t } = f, { $el: i, $dragEl: l } = s; E = !0, S = a.target === l[0] || a.target === l ? r(a) - a.target.getBoundingClientRect()[f.isHorizontal() ? "left" : "top"] : null, a.preventDefault(), a.stopPropagation(), t.transition(100), l.transition(100), n(a), clearTimeout(T), i.transition(0), e.hide && i.css("opacity", 1), f.params.cssMode && f.$wrapperEl.css("scroll-snap-type", "none"), y("scrollbarDragStart", a) } function o(a) { const { scrollbar: e, $wrapperEl: s } = f, { $el: t, $dragEl: i } = e; E && (a.preventDefault ? a.preventDefault() : a.returnValue = !1, n(a), s.transition(0), t.transition(0), i.transition(0), y("scrollbarDragMove", a)) } function p(a) { const e = f.params.scrollbar, { scrollbar: s, $wrapperEl: t } = f, { $el: i } = s; E && (E = !1, f.params.cssMode && (f.$wrapperEl.css("scroll-snap-type", ""), t.transition("")), e.hide && (clearTimeout(T), T = v(() => { i.css("opacity", 0), i.transition(400) }, 1e3)), y("scrollbarDragEnd", a), e.snapOnRelease && f.slideToClosest()) } function c(e) { const { scrollbar: a, touchEventsTouch: s, touchEventsDesktop: t, params: i, support: r } = f, n = a.$el; if (!n) return; const d = n[0], c = !!(r.passiveListener && i.passiveListeners) && { passive: !1, capture: !1 }, m = !!(r.passiveListener && i.passiveListeners) && { passive: !0, capture: !1 }; if (d) { const a = "on" === e ? "addEventListener" : "removeEventListener"; r.touch ? (d[a](s.start, l, c), d[a](s.move, o, c), d[a](s.end, p, m)) : (d[a](t.start, l, c), x[a](t.move, o, c), x[a](t.end, p, m)) } } function m() { f.params.scrollbar.el && f.scrollbar.el && c("on") } function u() { f.params.scrollbar.el && f.scrollbar.el && c("off") } function h() { const { scrollbar: e, $el: a } = f; f.params.scrollbar = V(f, f.originalParams.scrollbar, f.params.scrollbar, { el: "swiper-scrollbar" }); const s = f.params.scrollbar; if (!s.el) return; let t = d(s.el); f.params.uniqueNavElements && "string" == typeof s.el && 1 < t.length && 1 === a.find(s.el).length && (t = a.find(s.el)), t.addClass(f.isHorizontal() ? s.horizontalClass : s.verticalClass); let i = t.find(`.${f.params.scrollbar.dragClass}`); 0 === i.length && (i = d(`<div class="${f.params.scrollbar.dragClass}"></div>`), t.append(i)), Object.assign(e, { $el: t, el: t[0], $dragEl: i, dragEl: i[0] }), s.draggable && m(), t && t[f.enabled ? "removeClass" : "addClass"](f.params.scrollbar.lockClass) } function g() { const e = f.params.scrollbar, a = f.scrollbar.$el; a && a.removeClass(f.isHorizontal() ? e.horizontalClass : e.verticalClass), u() } let { swiper: f, extendParams: w, on: b, emit: y } = e; const x = s(); let E = !1, C = null, T = null, S, P, k, $; w({ scrollbar: { el: null, dragSize: "auto", hide: !1, draggable: !1, snapOnRelease: !0, lockClass: "swiper-scrollbar-lock", dragClass: "swiper-scrollbar-drag", scrollbarDisabledClass: "swiper-scrollbar-disabled", horizontalClass: `swiper-scrollbar-horizontal`, verticalClass: `swiper-scrollbar-vertical` } }), f.scrollbar = { el: null, dragEl: null, $el: null, $dragEl: null }, b("init", () => { !1 === f.params.scrollbar.enabled ? M() : (h(), i(), a()) }), b("update resize observerUpdate lock unlock", () => { i() }), b("setTranslate", () => { a() }), b("setTransition", (e, a) => { t(a) }), b("enable disable", () => { const { $el: e } = f.scrollbar; e && e[f.enabled ? "removeClass" : "addClass"](f.params.scrollbar.lockClass) }), b("destroy", () => { g() }); const M = () => { f.$el.addClass(f.params.scrollbar.scrollbarDisabledClass), f.scrollbar.$el && f.scrollbar.$el.addClass(f.params.scrollbar.scrollbarDisabledClass), g() }; Object.assign(f.scrollbar, { enable: () => { f.$el.removeClass(f.params.scrollbar.scrollbarDisabledClass), f.scrollbar.$el && f.scrollbar.$el.removeClass(f.params.scrollbar.scrollbarDisabledClass), h(), i(), a() }, disable: M, updateSize: i, setTranslate: a, init: h, destroy: g }) }, function (e) { let { swiper: a, extendParams: s, on: t } = e; s({ parallax: { enabled: !1 } }); const i = (e, s) => { const { rtl: t } = a, i = d(e), r = t ? -1 : 1, n = i.attr("data-swiper-parallax") || "0"; let l = i.attr("data-swiper-parallax-x"), o = i.attr("data-swiper-parallax-y"); const p = i.attr("data-swiper-parallax-scale"), c = i.attr("data-swiper-parallax-opacity"); if (l || o ? (l = l || "0", o = o || "0") : a.isHorizontal() ? (l = n, o = "0") : (o = n, l = "0"), l = 0 <= l.indexOf("%") ? `${parseInt(l, 10) * s * r}%` : `${l * s * r}px`, o = 0 <= o.indexOf("%") ? `${parseInt(o, 10) * s}%` : `${o * s}px`, "undefined" != typeof c && null !== c) { const e = c - (c - 1) * (1 - Math.abs(s)); i[0].style.opacity = e } if ("undefined" == typeof p || null === p) i.transform(`translate3d(${l}, ${o}, 0px)`); else { const e = p - (p - 1) * (1 - Math.abs(s)); i.transform(`translate3d(${l}, ${o}, 0px) scale(${e})`) } }, r = () => { const { $el: e, slides: s, progress: t, snapGrid: r } = a; e.children("[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]").each(e => { i(e, t) }), s.each((e, s) => { let n = e.progress; 1 < a.params.slidesPerGroup && "auto" !== a.params.slidesPerView && (n += Math.ceil(s / 2) - t * (r.length - 1)), n = Math.min(Math.max(n, -1), 1), d(e).find("[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]").each(e => { i(e, n) }) }) }, n = function (e) { void 0 === e && (e = a.params.speed); const { $el: s } = a; s.find("[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]").each(a => { const s = d(a); let t = parseInt(s.attr("data-swiper-parallax-duration"), 10) || e; 0 === e && (t = 0), s.transition(t) }) }; t("beforeInit", () => { a.params.parallax.enabled && (a.params.watchSlidesProgress = !0, a.originalParams.watchSlidesProgress = !0) }), t("init", () => { a.params.parallax.enabled && r() }), t("setTranslate", () => { a.params.parallax.enabled && r() }), t("setTransition", (e, s) => { a.params.parallax.enabled && n(s) }) }, function (e) { function a(a) { if (2 > a.targetTouches.length) return 1; const e = a.targetTouches[0].pageX, s = a.targetTouches[0].pageY, t = a.targetTouches[1].pageX, i = a.targetTouches[1].pageY, r = Math.sqrt((t - e) ** 2 + (i - s) ** 2); return r } function s(s) { const e = E.support, t = E.params.zoom; if (z = !1, L = !1, !e.gestures) { if ("touchstart" !== s.type || "touchstart" === s.type && 2 > s.targetTouches.length) return; z = !0, I.scaleStart = a(s) } return I.$slideEl && I.$slideEl.length || (I.$slideEl = d(s.target).closest(`.${E.params.slideClass}`), 0 === I.$slideEl.length && (I.$slideEl = E.slides.eq(E.activeIndex)), I.$imageEl = I.$slideEl.find(`.${t.containerClass}`).eq(0).find("picture, img, svg, canvas, .swiper-zoom-target").eq(0), I.$imageWrapEl = I.$imageEl.parent(`.${t.containerClass}`), I.maxRatio = I.$imageWrapEl.attr("data-swiper-zoom") || t.maxRatio, 0 !== I.$imageWrapEl.length) ? void (I.$imageEl && I.$imageEl.transition(0), $ = !0) : void (I.$imageEl = void 0) } function i(t) { const e = E.support, i = E.params.zoom, r = E.zoom; if (!e.gestures) { if ("touchmove" !== t.type || "touchmove" === t.type && 2 > t.targetTouches.length) return; L = !0, I.scaleMove = a(t) } return I.$imageEl && 0 !== I.$imageEl.length ? void (r.scale = e.gestures ? t.scale * k : I.scaleMove / I.scaleStart * k, r.scale > I.maxRatio && (r.scale = I.maxRatio - 1 + (r.scale - I.maxRatio + 1) ** .5), r.scale < i.minRatio && (r.scale = i.minRatio + 1 - (i.minRatio - r.scale + 1) ** .5), I.$imageEl.transform(`translate3d(0,0,0) scale(${r.scale})`)) : void ("gesturechange" === t.type && s(t)) } function r(a) { const e = E.device, s = E.support, t = E.params.zoom, i = E.zoom; if (!s.gestures) { if (!z || !L) return; if ("touchend" !== a.type || "touchend" === a.type && 2 > a.changedTouches.length && !e.android) return; z = !1, L = !1 } I.$imageEl && 0 !== I.$imageEl.length && (i.scale = Math.max(Math.min(i.scale, I.maxRatio), t.minRatio), I.$imageEl.transition(E.params.speed).transform(`translate3d(0,0,0) scale(${i.scale})`), k = i.scale, $ = !1, 1 === i.scale && (I.$slideEl = void 0)) } function n(a) { const e = E.device; !I.$imageEl || 0 === I.$imageEl.length || D.isTouched || (e.android && a.cancelable && a.preventDefault(), D.isTouched = !0, D.touchesStart.x = "touchstart" === a.type ? a.targetTouches[0].pageX : a.pageX, D.touchesStart.y = "touchstart" === a.type ? a.targetTouches[0].pageY : a.pageY) } function l(a) { const e = E.zoom; if (!I.$imageEl || 0 === I.$imageEl.length) return; if (E.allowClick = !1, !D.isTouched || !I.$slideEl) return; D.isMoved || (D.width = I.$imageEl[0].offsetWidth, D.height = I.$imageEl[0].offsetHeight, D.startX = y(I.$imageWrapEl[0], "x") || 0, D.startY = y(I.$imageWrapEl[0], "y") || 0, I.slideWidth = I.$slideEl[0].offsetWidth, I.slideHeight = I.$slideEl[0].offsetHeight, I.$imageWrapEl.transition(0)); const s = D.width * e.scale, t = D.height * e.scale; if (!(s < I.slideWidth && t < I.slideHeight)) { if (D.minX = Math.min(I.slideWidth / 2 - s / 2, 0), D.maxX = -D.minX, D.minY = Math.min(I.slideHeight / 2 - t / 2, 0), D.maxY = -D.minY, D.touchesCurrent.x = "touchmove" === a.type ? a.targetTouches[0].pageX : a.pageX, D.touchesCurrent.y = "touchmove" === a.type ? a.targetTouches[0].pageY : a.pageY, !D.isMoved && !$) { if (E.isHorizontal() && (Math.floor(D.minX) === Math.floor(D.startX) && D.touchesCurrent.x < D.touchesStart.x || Math.floor(D.maxX) === Math.floor(D.startX) && D.touchesCurrent.x > D.touchesStart.x)) return void (D.isTouched = !1); if (!E.isHorizontal() && (Math.floor(D.minY) === Math.floor(D.startY) && D.touchesCurrent.y < D.touchesStart.y || Math.floor(D.maxY) === Math.floor(D.startY) && D.touchesCurrent.y > D.touchesStart.y)) return void (D.isTouched = !1) } a.cancelable && a.preventDefault(), a.stopPropagation(), D.isMoved = !0, D.currentX = D.touchesCurrent.x - D.touchesStart.x + D.startX, D.currentY = D.touchesCurrent.y - D.touchesStart.y + D.startY, D.currentX < D.minX && (D.currentX = D.minX + 1 - (D.minX - D.currentX + 1) ** .8), D.currentX > D.maxX && (D.currentX = D.maxX - 1 + (D.currentX - D.maxX + 1) ** .8), D.currentY < D.minY && (D.currentY = D.minY + 1 - (D.minY - D.currentY + 1) ** .8), D.currentY > D.maxY && (D.currentY = D.maxY - 1 + (D.currentY - D.maxY + 1) ** .8), O.prevPositionX || (O.prevPositionX = D.touchesCurrent.x), O.prevPositionY || (O.prevPositionY = D.touchesCurrent.y), O.prevTime || (O.prevTime = Date.now()), O.x = (D.touchesCurrent.x - O.prevPositionX) / (Date.now() - O.prevTime) / 2, O.y = (D.touchesCurrent.y - O.prevPositionY) / (Date.now() - O.prevTime) / 2, 2 > Math.abs(D.touchesCurrent.x - O.prevPositionX) && (O.x = 0), 2 > Math.abs(D.touchesCurrent.y - O.prevPositionY) && (O.y = 0), O.prevPositionX = D.touchesCurrent.x, O.prevPositionY = D.touchesCurrent.y, O.prevTime = Date.now(), I.$imageWrapEl.transform(`translate3d(${D.currentX}px, ${D.currentY}px,0)`) } } function o() { const e = E.zoom; if (!I.$imageEl || 0 === I.$imageEl.length) return; if (!D.isTouched || !D.isMoved) return D.isTouched = !1, void (D.isMoved = !1); D.isTouched = !1, D.isMoved = !1; let a = 300, s = 300; const t = O.x * a, i = D.currentX + t, r = O.y * s, n = D.currentY + r; 0 !== O.x && (a = Math.abs((i - D.currentX) / O.x)), 0 !== O.y && (s = Math.abs((n - D.currentY) / O.y)); const l = Math.max(a, s); D.currentX = i, D.currentY = n; const o = D.width * e.scale, d = D.height * e.scale; D.minX = Math.min(I.slideWidth / 2 - o / 2, 0), D.maxX = -D.minX, D.minY = Math.min(I.slideHeight / 2 - d / 2, 0), D.maxY = -D.minY, D.currentX = Math.max(Math.min(D.currentX, D.maxX), D.minX), D.currentY = Math.max(Math.min(D.currentY, D.maxY), D.minY), I.$imageWrapEl.transition(l).transform(`translate3d(${D.currentX}px, ${D.currentY}px,0)`) } function p() { const e = E.zoom; I.$slideEl && E.previousIndex !== E.activeIndex && (I.$imageEl && I.$imageEl.transform("translate3d(0,0,0) scale(1)"), I.$imageWrapEl && I.$imageWrapEl.transform("translate3d(0,0,0)"), e.scale = 1, k = 1, I.$slideEl = void 0, I.$imageEl = void 0, I.$imageWrapEl = void 0) } function c(a) { const e = E.zoom, s = E.params.zoom; if (I.$slideEl || (a && a.target && (I.$slideEl = d(a.target).closest(`.${E.params.slideClass}`)), !I.$slideEl && (E.params.virtual && E.params.virtual.enabled && E.virtual ? I.$slideEl = E.$wrapperEl.children(`.${E.params.slideActiveClass}`) : I.$slideEl = E.slides.eq(E.activeIndex)), I.$imageEl = I.$slideEl.find(`.${s.containerClass}`).eq(0).find("picture, img, svg, canvas, .swiper-zoom-target").eq(0), I.$imageWrapEl = I.$imageEl.parent(`.${s.containerClass}`)), !I.$imageEl || 0 === I.$imageEl.length || !I.$imageWrapEl || 0 === I.$imageWrapEl.length) return; E.params.cssMode && (E.wrapperEl.style.overflow = "hidden", E.wrapperEl.style.touchAction = "none"), I.$slideEl.addClass(`${s.zoomedSlideClass}`); let t, i, r, n, l, o, p, c, m, u, h, g, f, v, w, b, y, x; "undefined" == typeof D.touchesStart.x && a ? (t = "touchend" === a.type ? a.changedTouches[0].pageX : a.pageX, i = "touchend" === a.type ? a.changedTouches[0].pageY : a.pageY) : (t = D.touchesStart.x, i = D.touchesStart.y), e.scale = I.$imageWrapEl.attr("data-swiper-zoom") || s.maxRatio, k = I.$imageWrapEl.attr("data-swiper-zoom") || s.maxRatio, a ? (y = I.$slideEl[0].offsetWidth, x = I.$slideEl[0].offsetHeight, r = I.$slideEl.offset().left + P.scrollX, n = I.$slideEl.offset().top + P.scrollY, l = r + y / 2 - t, o = n + x / 2 - i, m = I.$imageEl[0].offsetWidth, u = I.$imageEl[0].offsetHeight, h = m * e.scale, g = u * e.scale, f = Math.min(y / 2 - h / 2, 0), v = Math.min(x / 2 - g / 2, 0), w = -f, b = -v, p = l * e.scale, c = o * e.scale, p < f && (p = f), p > w && (p = w), c < v && (c = v), c > b && (c = b)) : (p = 0, c = 0), I.$imageWrapEl.transition(300).transform(`translate3d(${p}px, ${c}px,0)`), I.$imageEl.transition(300).transform(`translate3d(0,0,0) scale(${e.scale})`) } function m() { const e = E.zoom, a = E.params.zoom; I.$slideEl || (I.$slideEl = E.params.virtual && E.params.virtual.enabled && E.virtual ? E.$wrapperEl.children(`.${E.params.slideActiveClass}`) : E.slides.eq(E.activeIndex), I.$imageEl = I.$slideEl.find(`.${a.containerClass}`).eq(0).find("picture, img, svg, canvas, .swiper-zoom-target").eq(0), I.$imageWrapEl = I.$imageEl.parent(`.${a.containerClass}`)), I.$imageEl && 0 !== I.$imageEl.length && I.$imageWrapEl && 0 !== I.$imageWrapEl.length && (E.params.cssMode && (E.wrapperEl.style.overflow = "", E.wrapperEl.style.touchAction = ""), e.scale = 1, k = 1, I.$imageWrapEl.transition(300).transform("translate3d(0,0,0)"), I.$imageEl.transition(300).transform("translate3d(0,0,0) scale(1)"), I.$slideEl.removeClass(`${a.zoomedSlideClass}`), I.$slideEl = void 0) } function u(a) { const e = E.zoom; e.scale && 1 !== e.scale ? m() : c(a) } function h() { const e = E.support, a = !!("touchstart" === E.touchEvents.start && e.passiveListener && E.params.passiveListeners) && { passive: !0, capture: !1 }, s = !e.passiveListener || { passive: !1, capture: !0 }; return { passiveListener: a, activeListenerWithCapture: s } } function g() { return `.${E.params.slideClass}` } function f(e) { const { passiveListener: a } = h(), t = g(); E.$wrapperEl[e]("gesturestart", t, s, a), E.$wrapperEl[e]("gesturechange", t, i, a), E.$wrapperEl[e]("gestureend", t, r, a) } function v() { M || (M = !0, f("on")) } function w() { M && (M = !1, f("off")) } function b() { const e = E.zoom; if (e.enabled) return; e.enabled = !0; const a = E.support, { passiveListener: t, activeListenerWithCapture: n } = h(), o = g(); a.gestures ? (E.$wrapperEl.on(E.touchEvents.start, v, t), E.$wrapperEl.on(E.touchEvents.end, w, t)) : "touchstart" === E.touchEvents.start && (E.$wrapperEl.on(E.touchEvents.start, o, s, t), E.$wrapperEl.on(E.touchEvents.move, o, i, n), E.$wrapperEl.on(E.touchEvents.end, o, r, t), E.touchEvents.cancel && E.$wrapperEl.on(E.touchEvents.cancel, o, r, t)), E.$wrapperEl.on(E.touchEvents.move, `.${E.params.zoom.containerClass}`, l, n) } function x() { const e = E.zoom; if (!e.enabled) return; const a = E.support; e.enabled = !1; const { passiveListener: t, activeListenerWithCapture: n } = h(), o = g(); a.gestures ? (E.$wrapperEl.off(E.touchEvents.start, v, t), E.$wrapperEl.off(E.touchEvents.end, w, t)) : "touchstart" === E.touchEvents.start && (E.$wrapperEl.off(E.touchEvents.start, o, s, t), E.$wrapperEl.off(E.touchEvents.move, o, i, n), E.$wrapperEl.off(E.touchEvents.end, o, r, t), E.touchEvents.cancel && E.$wrapperEl.off(E.touchEvents.cancel, o, r, t)), E.$wrapperEl.off(E.touchEvents.move, `.${E.params.zoom.containerClass}`, l, n) } let { swiper: E, extendParams: C, on: T, emit: S } = e; const P = t(); C({ zoom: { enabled: !1, maxRatio: 3, minRatio: 1, toggle: !0, containerClass: "swiper-zoom-container", zoomedSlideClass: "swiper-slide-zoomed" } }), E.zoom = { enabled: !1 }; let k = 1, $ = !1, M, z, L; const I = { $slideEl: void 0, slideWidth: void 0, slideHeight: void 0, $imageEl: void 0, $imageWrapEl: void 0, maxRatio: 3 }, D = { isTouched: void 0, isMoved: void 0, currentX: void 0, currentY: void 0, minX: void 0, minY: void 0, maxX: void 0, maxY: void 0, width: void 0, height: void 0, startX: void 0, startY: void 0, touchesStart: {}, touchesCurrent: {} }, O = { x: void 0, y: void 0, prevPositionX: void 0, prevPositionY: void 0, prevTime: void 0 }; let A = 1; Object.defineProperty(E.zoom, "scale", { get() { return A }, set(e) { if (A !== e) { const a = I.$imageEl ? I.$imageEl[0] : void 0, s = I.$slideEl ? I.$slideEl[0] : void 0; S("zoomChange", e, a, s) } A = e } }), T("init", () => { E.params.zoom.enabled && b() }), T("destroy", () => { x() }), T("touchStart", (a, s) => { E.zoom.enabled && n(s) }), T("touchEnd", () => { E.zoom.enabled && o() }), T("doubleTap", (a, s) => { !E.animating && E.params.zoom.enabled && E.zoom.enabled && E.params.zoom.toggle && u(s) }), T("transitionEnd", () => { E.zoom.enabled && E.params.zoom.enabled && p() }), T("slideChange", () => { E.zoom.enabled && E.params.zoom.enabled && E.params.cssMode && p() }), Object.assign(E.zoom, { enable: b, disable: x, in: c, out: m, toggle: u }) }, function (e) { function a(e, s) { void 0 === s && (s = !0); const t = r.params.lazy; if ("undefined" == typeof e) return; if (0 === r.slides.length) return; const i = r.virtual && r.params.virtual.enabled, n = i ? r.$wrapperEl.children(`.${r.params.slideClass}[data-swiper-slide-index="${e}"]`) : r.slides.eq(e), l = n.find(`.${t.elementClass}:not(.${t.loadedClass}):not(.${t.loadingClass})`); !n.hasClass(t.elementClass) || n.hasClass(t.loadedClass) || n.hasClass(t.loadingClass) || l.push(n[0]), 0 === l.length || l.each(e => { const i = d(e); i.addClass(t.loadingClass); const l = i.attr("data-background"), p = i.attr("data-src"), c = i.attr("data-srcset"), m = i.attr("data-sizes"), u = i.parent("picture"); r.loadImage(i[0], p || l, c, m, !1, () => { if ("undefined" != typeof r && null !== r && r && (!r || r.params) && !r.destroyed) { if (l ? (i.css("background-image", `url("${l}")`), i.removeAttr("data-background")) : (c && (i.attr("srcset", c), i.removeAttr("data-srcset")), m && (i.attr("sizes", m), i.removeAttr("data-sizes")), u.length && u.children("source").each(e => { const a = d(e); a.attr("data-srcset") && (a.attr("srcset", a.attr("data-srcset")), a.removeAttr("data-srcset")) }), p && (i.attr("src", p), i.removeAttr("data-src"))), i.addClass(t.loadedClass).removeClass(t.loadingClass), n.find(`.${t.preloaderClass}`).remove(), r.params.loop && s) { const e = n.attr("data-swiper-slide-index"); if (n.hasClass(r.params.slideDuplicateClass)) { const s = r.$wrapperEl.children(`[data-swiper-slide-index="${e}"]:not(.${r.params.slideDuplicateClass})`); a(s.index(), !1) } else { const s = r.$wrapperEl.children(`.${r.params.slideDuplicateClass}[data-swiper-slide-index="${e}"]`); a(s.index(), !1) } } o("lazyImageReady", n[0], i[0]), r.params.autoHeight && r.updateAutoHeight() } }), o("lazyImageLoad", n[0], i[0]) }) } function s() { function e(e) { if (o) { if (t.children(`.${i.slideClass}[data-swiper-slide-index="${e}"]`).length) return !0; } else if (n[e]) return !0; return !1 } function s(e) { return o ? d(e).attr("data-swiper-slide-index") : d(e).index() } const { $wrapperEl: t, params: i, slides: n, activeIndex: l } = r, o = r.virtual && i.virtual.enabled, p = i.lazy; let m = i.slidesPerView; if ("auto" === m && (m = 0), c || (c = !0), r.params.watchSlidesProgress) t.children(`.${i.slideVisibleClass}`).each(e => { const s = o ? d(e).attr("data-swiper-slide-index") : d(e).index(); a(s) }); else if (1 < m) for (let s = l; s < l + m; s += 1)e(s) && a(s); else a(l); if (p.loadPrevNext) if (1 < m || p.loadPrevNextAmount && 1 < p.loadPrevNextAmount) { const s = p.loadPrevNextAmount, t = Math.ceil(m), r = Math.min(l + t + Math.max(s, t), n.length), o = Math.max(l - Math.max(t, s), 0); for (let s = l + t; s < r; s += 1)e(s) && a(s); for (let s = o; s < l; s += 1)e(s) && a(s) } else { const e = t.children(`.${i.slideNextClass}`); 0 < e.length && a(s(e)); const r = t.children(`.${i.slidePrevClass}`); 0 < r.length && a(s(r)) } } function i() { const e = t(); if (!r || r.destroyed) return; const a = r.params.lazy.scrollingElement ? d(r.params.lazy.scrollingElement) : d(e), n = a[0] === e, l = n ? e.innerWidth : a[0].offsetWidth, o = n ? e.innerHeight : a[0].offsetHeight, c = r.$el.offset(), { rtlTranslate: m } = r; let u = !1; m && (c.left -= r.$el[0].scrollLeft); const h = [[c.left, c.top], [c.left + r.width, c.top], [c.left, c.top + r.height], [c.left + r.width, c.top + r.height]]; for (let e = 0; e < h.length; e += 1) { const a = h[e]; if (0 <= a[0] && a[0] <= l && 0 <= a[1] && a[1] <= o) { if (0 === a[0] && 0 === a[1]) continue; u = !0 } } const g = !!("touchstart" === r.touchEvents.start && r.support.passiveListener && r.params.passiveListeners) && { passive: !0, capture: !1 }; u ? (s(), a.off("scroll", i, g)) : !p && (p = !0, a.on("scroll", i, g)) } let { swiper: r, extendParams: n, on: l, emit: o } = e; n({ lazy: { checkInView: !1, enabled: !1, loadPrevNext: !1, loadPrevNextAmount: 1, loadOnTransitionStart: !1, scrollingElement: "", elementClass: "swiper-lazy", loadingClass: "swiper-lazy-loading", loadedClass: "swiper-lazy-loaded", preloaderClass: "swiper-lazy-preloader" } }), r.lazy = {}; let p = !1, c = !1; l("beforeInit", () => { r.params.lazy.enabled && r.params.preloadImages && (r.params.preloadImages = !1) }), l("init", () => { r.params.lazy.enabled && (r.params.lazy.checkInView ? i() : s()) }), l("scroll", () => { r.params.freeMode && r.params.freeMode.enabled && !r.params.freeMode.sticky && s() }), l("scrollbarDragMove resize _freeModeNoMomentumRelease", () => { r.params.lazy.enabled && (r.params.lazy.checkInView ? i() : s()) }), l("transitionStart", () => { r.params.lazy.enabled && (r.params.lazy.loadOnTransitionStart || !r.params.lazy.loadOnTransitionStart && !c) && (r.params.lazy.checkInView ? i() : s()) }), l("transitionEnd", () => { r.params.lazy.enabled && !r.params.lazy.loadOnTransitionStart && (r.params.lazy.checkInView ? i() : s()) }), l("slideChange", () => { const { lazy: e, cssMode: a, watchSlidesProgress: t, touchReleaseOnEdges: i, resistanceRatio: n } = r.params; e.enabled && (a || t && (i || 0 === n)) && s() }), l("destroy", () => { r.$el && r.$el.find(`.${r.params.lazy.loadingClass}`).removeClass(r.params.lazy.loadingClass) }), Object.assign(r.lazy, { load: s, loadInSlide: a }) }, function (e) { function a(e, a) { const s = function () { let e, a, s; return (t, i) => { for (a = -1, e = t.length; 1 < e - a;)s = e + a >> 1, t[s] <= i ? a = s : e = s; return e } }(); this.x = e, this.y = a, this.lastIndex = e.length - 1; let t, i; return this.interpolate = function (e) { return e ? (i = s(this.x, e), t = i - 1, (e - this.x[t]) * (this.y[i] - this.y[t]) / (this.x[i] - this.x[t]) + this.y[t]) : 0 }, this } function s(e) { r.controller.spline || (r.controller.spline = r.params.loop ? new a(r.slidesGrid, e.slidesGrid) : new a(r.snapGrid, e.snapGrid)) } function t() { !r.controller.control || r.controller.spline && (r.controller.spline = void 0, delete r.controller.spline) } let { swiper: r, extendParams: n, on: l } = e; n({ controller: { control: void 0, inverse: !1, by: "slide" } }), r.controller = { control: void 0 }, l("beforeInit", () => { r.controller.control = r.params.controller.control }), l("update", () => { t() }), l("resize", () => { t() }), l("observerUpdate", () => { t() }), l("setTranslate", (e, a, s) => { r.controller.control && r.controller.setTranslate(a, s) }), l("setTransition", (e, a, s) => { r.controller.control && r.controller.setTransition(a, s) }), Object.assign(r.controller, { setTranslate: function (e, a) { function t(e) { const a = r.rtlTranslate ? -r.translate : r.translate; "slide" === r.params.controller.by && (s(e), o = -r.controller.spline.interpolate(-a)), o && "container" !== r.params.controller.by || (l = (e.maxTranslate() - e.minTranslate()) / (r.maxTranslate() - r.minTranslate()), o = (a - r.minTranslate()) * l + e.minTranslate()), r.params.controller.inverse && (o = e.maxTranslate() - o), e.updateProgress(o), e.setTranslate(o, r), e.updateActiveIndex(), e.updateSlidesClasses() } const n = r.controller.control; let l, o; const d = r.constructor; if (Array.isArray(n)) for (let e = 0; e < n.length; e += 1)n[e] !== a && n[e] instanceof d && t(n[e]); else n instanceof d && a !== n && t(n) }, setTransition: function (e, a) { function s(a) { a.setTransition(e, r), 0 !== e && (a.transitionStart(), a.params.autoHeight && v(() => { a.updateAutoHeight() }), a.$wrapperEl.transitionEnd(() => { n && (a.params.loop && "slide" === r.params.controller.by && a.loopFix(), a.transitionEnd()) })) } const t = r.constructor, n = r.controller.control; let l; if (Array.isArray(n)) for (l = 0; l < n.length; l += 1)n[l] !== a && n[l] instanceof t && s(n[l]); else n instanceof t && a !== n && s(n) } }) }, function (e) { function a(e) { const a = C; 0 === a.length || (a.html(""), a.html(e)) } function s(e) { void 0 === e && (e = 16); return "x".repeat(e).replace(/x/g, () => Math.round(16 * Math.random()).toString(16)) } function t(e) { e.attr("tabIndex", "0") } function i(e) { e.attr("tabIndex", "-1") } function r(e, a) { e.attr("role", a) } function n(e, a) { e.attr("aria-roledescription", a) } function l(e, a) { e.attr("aria-controls", a) } function o(e, a) { e.attr("aria-label", a) } function p(e, a) { e.attr("id", a) } function c(e, a) { e.attr("aria-live", a) } function m(e) { e.attr("aria-disabled", !0) } function u(e) { e.attr("aria-disabled", !1) } function h(s) { if (13 !== s.keyCode && 32 !== s.keyCode) return; const e = y.params.a11y, t = d(s.target); y.navigation && y.navigation.$nextEl && t.is(y.navigation.$nextEl) && ((!y.isEnd || y.params.loop) && y.slideNext(), y.isEnd ? a(e.lastSlideMessage) : a(e.nextSlideMessage)), y.navigation && y.navigation.$prevEl && t.is(y.navigation.$prevEl) && ((!y.isBeginning || y.params.loop) && y.slidePrev(), y.isBeginning ? a(e.firstSlideMessage) : a(e.prevSlideMessage)), y.pagination && t.is(F(y.params.pagination.bulletClass)) && t[0].click() } function g() { if (!(y.params.loop || y.params.rewind || !y.navigation)) { const { $nextEl: e, $prevEl: a } = y.navigation; a && 0 < a.length && (y.isBeginning ? (m(a), i(a)) : (u(a), t(a))), e && 0 < e.length && (y.isEnd ? (m(e), i(e)) : (u(e), t(e))) } } function f() { return y.pagination && y.pagination.bullets && y.pagination.bullets.length } function v() { return f() && y.params.pagination.clickable } function w() { const e = y.params.a11y; f() && y.pagination.bullets.each(a => { const s = d(a); y.params.pagination.clickable && (t(s), !y.params.pagination.renderBullet && (r(s, "button"), o(s, e.paginationBulletMessage.replace(/\{\{index\}\}/, s.index() + 1)))), s.is(`.${y.params.pagination.bulletActiveClass}`) ? s.attr("aria-current", "true") : s.removeAttr("aria-current") }) } function b() { C && 0 < C.length && C.remove(); let e, a; y.navigation && y.navigation.$nextEl && (e = y.navigation.$nextEl), y.navigation && y.navigation.$prevEl && (a = y.navigation.$prevEl), e && e.off("keydown", h), a && a.off("keydown", h), v() && y.pagination.$el.off("keydown", F(y.params.pagination.bulletClass), h), y.$el.off("focus", S, !0) } let { swiper: y, extendParams: x, on: E } = e; x({ a11y: { enabled: !0, notificationClass: "swiper-notification", prevSlideMessage: "Previous slide", nextSlideMessage: "Next slide", firstSlideMessage: "This is the first slide", lastSlideMessage: "This is the last slide", paginationBulletMessage: "Go to slide {{index}}", slideLabelMessage: "{{index}} / {{slidesLength}}", containerMessage: null, containerRoleDescriptionMessage: null, itemRoleDescriptionMessage: null, slideRole: "group", id: null } }); let C = null; const T = (e, a, s) => { t(e), "BUTTON" !== e[0].tagName && (r(e, "button"), e.on("keydown", h)), o(e, s), l(e, a) }, S = a => { const e = a.target.closest(`.${y.params.slideClass}`); if (!e || !y.slides.includes(e)) return; const s = y.slides.indexOf(e) === y.activeIndex, t = y.params.watchSlidesProgress && y.visibleSlides && y.visibleSlides.includes(e); s || t || (y.isHorizontal() ? y.el.scrollLeft = 0 : y.el.scrollTop = 0, y.slideTo(y.slides.indexOf(e), 0)) }, P = () => { const e = y.params.a11y; e.itemRoleDescriptionMessage && n(d(y.slides), e.itemRoleDescriptionMessage), e.slideRole && r(d(y.slides), e.slideRole); const a = y.params.loop ? y.slides.filter(e => !e.classList.contains(y.params.slideDuplicateClass)).length : y.slides.length; e.slideLabelMessage && y.slides.each((s, t) => { const i = d(s), r = y.params.loop ? parseInt(i.attr("data-swiper-slide-index"), 10) : t, n = e.slideLabelMessage.replace(/\{\{index\}\}/, r + 1).replace(/\{\{slidesLength\}\}/, a); o(i, n) }) }, k = () => { const e = y.params.a11y; y.$el.append(C); const a = y.$el; e.containerRoleDescriptionMessage && n(a, e.containerRoleDescriptionMessage), e.containerMessage && o(a, e.containerMessage); const t = y.$wrapperEl, i = e.id || t.attr("id") || `swiper-wrapper-${s(16)}`, r = y.params.autoplay && y.params.autoplay.enabled ? "off" : "polite"; p(t, i), c(t, r), P(); let l, d; y.navigation && y.navigation.$nextEl && (l = y.navigation.$nextEl), y.navigation && y.navigation.$prevEl && (d = y.navigation.$prevEl), l && l.length && T(l, i, e.nextSlideMessage), d && d.length && T(d, i, e.prevSlideMessage), v() && y.pagination.$el.on("keydown", F(y.params.pagination.bulletClass), h), y.$el.on("focus", S, !0) }; E("beforeInit", () => { C = d(`<span class="${y.params.a11y.notificationClass}" aria-live="assertive" aria-atomic="true"></span>`) }), E("afterInit", () => { y.params.a11y.enabled && k() }), E("slidesLengthChange snapGridLengthChange slidesGridLengthChange", () => { y.params.a11y.enabled && P() }), E("fromEdge toEdge afterInit lock unlock", () => { y.params.a11y.enabled && g() }), E("paginationUpdate", () => { y.params.a11y.enabled && w() }), E("destroy", () => { y.params.a11y.enabled && b() }) }, function (e) { let { swiper: a, extendParams: s, on: i } = e; s({ history: { enabled: !1, root: "", replaceState: !1, key: "slides", keepQuery: !1 } }); let r = !1, n = {}; const l = e => e.toString().replace(/\s+/g, "-").replace(/[^\w-]+/g, "").replace(/--+/g, "-").replace(/^-+/, "").replace(/-+$/, ""), o = e => { const a = t(); let s = e ? new URL(e) : a.location; const i = s.pathname.slice(1).split("/").filter(e => "" !== e), r = i.length, n = i[r - 2], l = i[r - 1]; return { key: n, value: l } }, d = (e, s) => { const i = t(); if (!r || !a.params.history.enabled) return; let n = a.params.url ? new URL(a.params.url) : i.location; const o = a.slides.eq(s); let d = l(o.attr("data-history")); if (0 < a.params.history.root.length) { let s = a.params.history.root; "/" === s[s.length - 1] && (s = s.slice(0, s.length - 1)), d = `${s}/${e}/${d}` } else n.pathname.includes(e) || (d = `${e}/${d}`); a.params.history.keepQuery && (d += n.search); const p = i.history.state; p && p.value === d || (a.params.history.replaceState ? i.history.replaceState({ value: d }, null, d) : i.history.pushState({ value: d }, null, d)) }, p = (e, s, t) => { if (s) for (let r = 0, i = a.slides.length; r < i; r += 1) { const i = a.slides.eq(r), n = l(i.attr("data-history")); if (n === s && !i.hasClass(a.params.slideDuplicateClass)) { const s = i.index(); a.slideTo(s, e, t) } } else a.slideTo(0, e, t) }, c = () => { n = o(a.params.url), p(a.params.speed, n.value, !1) }, m = () => { const e = t(); if (a.params.history) { if (!e.history || !e.history.pushState) return a.params.history.enabled = !1, void (a.params.hashNavigation.enabled = !0); r = !0, n = o(a.params.url), (n.key || n.value) && (p(0, n.value, a.params.runCallbacksOnInit), !a.params.history.replaceState && e.addEventListener("popstate", c)) } }, u = () => { const e = t(); a.params.history.replaceState || e.removeEventListener("popstate", c) }; i("init", () => { a.params.history.enabled && m() }), i("destroy", () => { a.params.history.enabled && u() }), i("transitionEnd _freeModeNoMomentumRelease", () => { r && d(a.params.history.key, a.activeIndex) }), i("slideChange", () => { r && a.params.cssMode && d(a.params.history.key, a.activeIndex) }) }, function (e) { let { swiper: a, extendParams: i, emit: r, on: n } = e, l = !1; const o = s(), p = t(); i({ hashNavigation: { enabled: !1, replaceState: !1, watchState: !1 } }); const c = () => { r("hashChange"); const e = o.location.hash.replace("#", ""), s = a.slides.eq(a.activeIndex).attr("data-hash"); if (e !== s) { const s = a.$wrapperEl.children(`.${a.params.slideClass}[data-hash="${e}"]`).index(); if ("undefined" == typeof s) return; a.slideTo(s) } }, m = () => { if (l && a.params.hashNavigation.enabled) if (a.params.hashNavigation.replaceState && p.history && p.history.replaceState) p.history.replaceState(null, null, `#${a.slides.eq(a.activeIndex).attr("data-hash")}` || ""), r("hashSet"); else { const e = a.slides.eq(a.activeIndex), s = e.attr("data-hash") || e.attr("data-history"); o.location.hash = s || "", r("hashSet") } }, u = () => { if (!(!a.params.hashNavigation.enabled || a.params.history && a.params.history.enabled)) { l = !0; const e = o.location.hash.replace("#", ""); if (e) { for (let s = 0, t = a.slides.length; s < t; s += 1) { const t = a.slides.eq(s), i = t.attr("data-hash") || t.attr("data-history"); if (i === e && !t.hasClass(a.params.slideDuplicateClass)) { const e = t.index(); a.slideTo(e, 0, a.params.runCallbacksOnInit, !0) } } } a.params.hashNavigation.watchState && d(p).on("hashchange", c) } }, h = () => { a.params.hashNavigation.watchState && d(p).off("hashchange", c) }; n("init", () => { a.params.hashNavigation.enabled && u() }), n("destroy", () => { a.params.hashNavigation.enabled && h() }), n("transitionEnd _freeModeNoMomentumRelease", () => { l && m() }), n("slideChange", () => { l && a.params.cssMode && m() }) }, function (e) { function a() { if (!m.size) return m.autoplay.running = !1, void (m.autoplay.paused = !1); const e = m.slides.eq(m.activeIndex); let s = m.params.autoplay.delay; e.attr("data-swiper-autoplay") && (s = e.attr("data-swiper-autoplay") || m.params.autoplay.delay), clearTimeout(f), f = v(() => { let e; m.params.autoplay.reverseDirection ? m.params.loop ? (m.loopFix(), e = m.slidePrev(m.params.speed, !0, !0), g("autoplay")) : m.isBeginning ? m.params.autoplay.stopOnLastSlide ? i() : (e = m.slideTo(m.slides.length - 1, m.params.speed, !0, !0), g("autoplay")) : (e = m.slidePrev(m.params.speed, !0, !0), g("autoplay")) : m.params.loop ? (m.loopFix(), e = m.slideNext(m.params.speed, !0, !0), g("autoplay")) : m.isEnd ? m.params.autoplay.stopOnLastSlide ? i() : (e = m.slideTo(0, m.params.speed, !0, !0), g("autoplay")) : (e = m.slideNext(m.params.speed, !0, !0), g("autoplay")), m.params.cssMode && m.autoplay.running ? a() : !1 === e && a() }, s) } function t() { return "undefined" == typeof f && !m.autoplay.running && (m.autoplay.running = !0, g("autoplayStart"), a(), !0) } function i() { return !!m.autoplay.running && "undefined" != typeof f && (f && (clearTimeout(f), f = void 0), m.autoplay.running = !1, g("autoplayStop"), !0) } function r(e) { !m.autoplay.running || m.autoplay.paused || (f && clearTimeout(f), m.autoplay.paused = !0, 0 !== e && m.params.autoplay.waitForTransition ? ["transitionend", "webkitTransitionEnd"].forEach(e => { m.$wrapperEl[0].addEventListener(e, l) }) : (m.autoplay.paused = !1, a())) } function n() { const e = s(); "hidden" === e.visibilityState && m.autoplay.running && r(), "visible" === e.visibilityState && m.autoplay.paused && (a(), m.autoplay.paused = !1) } function l(s) { m && !m.destroyed && m.$wrapperEl && s.target === m.$wrapperEl[0] && (["transitionend", "webkitTransitionEnd"].forEach(e => { m.$wrapperEl[0].removeEventListener(e, l) }), m.autoplay.paused = !1, m.autoplay.running ? a() : i()) } function o() { m.params.autoplay.disableOnInteraction ? i() : (g("autoplayPause"), r()), ["transitionend", "webkitTransitionEnd"].forEach(e => { m.$wrapperEl[0].removeEventListener(e, l) }) } function d() { m.params.autoplay.disableOnInteraction || (m.autoplay.paused = !1, g("autoplayResume"), a()) } function p() { m.params.autoplay.pauseOnMouseEnter && (m.$el.on("mouseenter", o), m.$el.on("mouseleave", d)) } function c() { m.$el.off("mouseenter", o), m.$el.off("mouseleave", d) } let { swiper: m, extendParams: u, on: h, emit: g } = e, f; m.autoplay = { running: !1, paused: !1 }, u({ autoplay: { enabled: !1, delay: 3e3, waitForTransition: !0, disableOnInteraction: !0, stopOnLastSlide: !1, reverseDirection: !1, pauseOnMouseEnter: !1 } }), h("init", () => { if (m.params.autoplay.enabled) { t(); const e = s(); e.addEventListener("visibilitychange", n), p() } }), h("beforeTransitionStart", (e, a, s) => { m.autoplay.running && (s || !m.params.autoplay.disableOnInteraction ? m.autoplay.pause(a) : i()) }), h("sliderFirstMove", () => { m.autoplay.running && (m.params.autoplay.disableOnInteraction ? i() : r()) }), h("touchEnd", () => { m.params.cssMode && m.autoplay.paused && !m.params.autoplay.disableOnInteraction && a() }), h("destroy", () => { c(), m.autoplay.running && i(); const e = s(); e.removeEventListener("visibilitychange", n) }), Object.assign(m.autoplay, { pause: r, run: a, start: t, stop: i }) }, function (e) { function a() { const e = r.thumbs.swiper; if (!e || e.destroyed) return; const a = e.clickedIndex, s = e.clickedSlide; if (s && d(s).hasClass(r.params.thumbs.slideThumbActiveClass)) return; if ("undefined" == typeof a || null === a) return; let t; if (t = e.params.loop ? parseInt(d(e.clickedSlide).attr("data-swiper-slide-index"), 10) : a, r.params.loop) { let e = r.activeIndex; r.slides.eq(e).hasClass(r.params.slideDuplicateClass) && (r.loopFix(), r._clientLeft = r.$wrapperEl[0].clientLeft, e = r.activeIndex); const a = r.slides.eq(e).prevAll(`[data-swiper-slide-index="${t}"]`).eq(0).index(), s = r.slides.eq(e).nextAll(`[data-swiper-slide-index="${t}"]`).eq(0).index(); t = "undefined" == typeof a ? s : "undefined" == typeof s ? a : s - e < e - a ? s : a } r.slideTo(t) } function s() { const { thumbs: e } = r.params; if (i) return !1; i = !0; const s = r.constructor; if (e.swiper instanceof s) r.thumbs.swiper = e.swiper, Object.assign(r.thumbs.swiper.originalParams, { watchSlidesProgress: !0, slideToClickedSlide: !1 }), Object.assign(r.thumbs.swiper.params, { watchSlidesProgress: !0, slideToClickedSlide: !1 }); else if (x(e.swiper)) { const a = Object.assign({}, e.swiper); Object.assign(a, { watchSlidesProgress: !0, slideToClickedSlide: !1 }), r.thumbs.swiper = new s(a), o = !0 } return r.thumbs.swiper.$el.addClass(r.params.thumbs.thumbsContainerClass), r.thumbs.swiper.on("tap", a), !0 } function t(e) { const a = r.thumbs.swiper; if (!a || a.destroyed) return; const s = "auto" === a.params.slidesPerView ? a.slidesPerViewDynamic() : a.params.slidesPerView; let t = 1; const n = r.params.thumbs.slideThumbActiveClass; if (1 < r.params.slidesPerView && !r.params.centeredSlides && (t = r.params.slidesPerView), r.params.thumbs.multipleActiveThumbs || (t = 1), t = Math.floor(t), a.slides.removeClass(n), a.params.loop || a.params.virtual && a.params.virtual.enabled) for (let e = 0; e < t; e += 1)a.$wrapperEl.children(`[data-swiper-slide-index="${r.realIndex + e}"]`).addClass(n); else for (let e = 0; e < t; e += 1)a.slides.eq(r.realIndex + e).addClass(n); const l = r.params.thumbs.autoScrollOffset, o = l && !a.params.loop; if (r.realIndex !== a.realIndex || o) { let t = a.activeIndex, i, n; if (a.params.loop) { a.slides.eq(t).hasClass(a.params.slideDuplicateClass) && (a.loopFix(), a._clientLeft = a.$wrapperEl[0].clientLeft, t = a.activeIndex); const e = a.slides.eq(t).prevAll(`[data-swiper-slide-index="${r.realIndex}"]`).eq(0).index(), s = a.slides.eq(t).nextAll(`[data-swiper-slide-index="${r.realIndex}"]`).eq(0).index(); i = "undefined" == typeof e ? s : "undefined" == typeof s ? e : s - t == t - e ? 1 < a.params.slidesPerGroup ? s : t : s - t < t - e ? s : e, n = r.activeIndex > r.previousIndex ? "next" : "prev" } else i = r.realIndex, n = i > r.previousIndex ? "next" : "prev"; if (o && (i += "next" === n ? l : -1 * l), a.visibleSlidesIndexes && 0 > a.visibleSlidesIndexes.indexOf(i)) { if (a.params.centeredSlides) i = i > t ? i - Math.floor(s / 2) + 1 : i + Math.floor(s / 2) - 1; else if (i > t && 1 === a.params.slidesPerGroup); a.slideTo(i, e ? 0 : void 0) } } } let { swiper: r, extendParams: n, on: l } = e; n({ thumbs: { swiper: null, multipleActiveThumbs: !0, autoScrollOffset: 0, slideThumbActiveClass: "swiper-slide-thumb-active", thumbsContainerClass: "swiper-thumbs" } }); let i = !1, o = !1; r.thumbs = { swiper: null }, l("beforeInit", () => { const { thumbs: e } = r.params; e && e.swiper && (s(), t(!0)) }), l("slideChange update resize observerUpdate", () => { t() }), l("setTransition", (e, a) => { const s = r.thumbs.swiper; !s || s.destroyed || s.setTransition(a) }), l("beforeDestroy", () => { const e = r.thumbs.swiper; !e || e.destroyed || o && e.destroy() }), Object.assign(r.thumbs, { init: s, update: t }) }, function (e) { let { swiper: a, extendParams: s, emit: t, once: i } = e; s({ freeMode: { enabled: !1, momentum: !0, momentumRatio: 1, momentumBounce: !0, momentumBounceRatio: 1, momentumVelocityRatio: 1, sticky: !1, minimumVelocity: .02 } }), Object.assign(a, { freeMode: { onTouchStart: function () { const e = a.getTranslate(); a.setTranslate(e), a.setTransition(0), a.touchEventsData.velocities.length = 0, a.freeMode.onTouchEnd({ currentPos: a.rtl ? a.translate : -a.translate }) }, onTouchMove: function () { const { touchEventsData: e, touches: s } = a; 0 === e.velocities.length && e.velocities.push({ position: s[a.isHorizontal() ? "startX" : "startY"], time: e.touchStartTime }), e.velocities.push({ position: s[a.isHorizontal() ? "currentX" : "currentY"], time: w() }) }, onTouchEnd: function (e) { let { currentPos: s } = e; const { params: r, $wrapperEl: n, rtlTranslate: l, snapGrid: o, touchEventsData: d } = a, p = w(), c = p - d.touchStartTime; if (s < -a.minTranslate()) return void a.slideTo(a.activeIndex); if (s > -a.maxTranslate()) return void (a.slides.length < o.length ? a.slideTo(o.length - 1) : a.slideTo(a.slides.length - 1)); if (r.freeMode.momentum) { if (1 < d.velocities.length) { const e = d.velocities.pop(), s = d.velocities.pop(), t = e.position - s.position, i = e.time - s.time; a.velocity = t / i, a.velocity /= 2, Math.abs(a.velocity) < r.freeMode.minimumVelocity && (a.velocity = 0), (150 < i || 300 < w() - e.time) && (a.velocity = 0) } else a.velocity = 0; a.velocity *= r.freeMode.momentumVelocityRatio, d.velocities.length = 0; let e = 1e3 * r.freeMode.momentumRatio; const s = a.velocity * e; let p = a.translate + s; l && (p = -p); let c = !1, m; const u = 20 * Math.abs(a.velocity) * r.freeMode.momentumBounceRatio; let h; if (p < a.maxTranslate()) r.freeMode.momentumBounce ? (p + a.maxTranslate() < -u && (p = a.maxTranslate() - u), m = a.maxTranslate(), c = !0, d.allowMomentumBounce = !0) : p = a.maxTranslate(), r.loop && r.centeredSlides && (h = !0); else if (p > a.minTranslate()) r.freeMode.momentumBounce ? (p - a.minTranslate() > u && (p = a.minTranslate() + u), m = a.minTranslate(), c = !0, d.allowMomentumBounce = !0) : p = a.minTranslate(), r.loop && r.centeredSlides && (h = !0); else if (r.freeMode.sticky) { let e; for (let a = 0; a < o.length; a += 1)if (o[a] > -p) { e = a; break } p = Math.abs(o[e] - p) < Math.abs(o[e - 1] - p) || "next" === a.swipeDirection ? o[e] : o[e - 1], p = -p } if (h && i("transitionEnd", () => { a.loopFix() }), 0 !== a.velocity) { if (e = l ? Math.abs((-p - a.translate) / a.velocity) : Math.abs((p - a.translate) / a.velocity), r.freeMode.sticky) { const s = Math.abs((l ? -p : p) - a.translate), t = a.slidesSizesGrid[a.activeIndex]; e = s < t ? r.speed : s < 2 * t ? 1.5 * r.speed : 2.5 * r.speed } } else if (r.freeMode.sticky) return void a.slideToClosest(); r.freeMode.momentumBounce && c ? (a.updateProgress(m), a.setTransition(e), a.setTranslate(p), a.transitionStart(!0, a.swipeDirection), a.animating = !0, n.transitionEnd(() => { a && !a.destroyed && d.allowMomentumBounce && (t("momentumBounce"), a.setTransition(r.speed), setTimeout(() => { a.setTranslate(m), n.transitionEnd(() => { !a || a.destroyed || a.transitionEnd() }) }, 0)) })) : a.velocity ? (t("_freeModeNoMomentumRelease"), a.updateProgress(p), a.setTransition(e), a.setTranslate(p), a.transitionStart(!0, a.swipeDirection), !a.animating && (a.animating = !0, n.transitionEnd(() => { !a || a.destroyed || a.transitionEnd() }))) : a.updateProgress(p), a.updateActiveIndex(), a.updateSlidesClasses() } else { if (r.freeMode.sticky) return void a.slideToClosest(); r.freeMode && t("_freeModeNoMomentumRelease") } (!r.freeMode.momentum || c >= r.longSwipesMs) && (a.updateProgress(), a.updateActiveIndex(), a.updateSlidesClasses()) } } }) }, function (e) { let { swiper: a, extendParams: s } = e; s({ grid: { rows: 1, fill: "column" } }); let t, r, n; const l = e => { const { slidesPerView: s } = a.params, { rows: i, fill: l } = a.params.grid; r = t / i, n = Math.floor(e / i), t = Math.floor(e / i) === e / i ? e : Math.ceil(e / i) * i, "auto" !== s && "row" === l && (t = Math.max(t, s * i)) }, o = (e, s, i, l) => { const { slidesPerGroup: o, spaceBetween: d } = a.params, { rows: p, fill: c } = a.params.grid; let m, u, h; if ("row" === c && 1 < o) { const a = Math.floor(e / (o * p)), r = e - p * o * a, n = 0 === a ? o : Math.min(Math.ceil((i - a * p * o) / p), o); h = Math.floor(r / n), u = r - h * n + a * o, m = u + h * t / p, s.css({ "-webkit-order": m, order: m }) } else "column" === c ? (u = Math.floor(e / p), h = e - u * p, (u > n || u === n && h === p - 1) && (h += 1, h >= p && (h = 0, u += 1))) : (h = Math.floor(e / r), u = e - h * r); s.css(l("margin-top"), 0 === h ? "" : d && `${d}px`) }, d = (e, s, i) => { const { spaceBetween: r, centeredSlides: n, roundLengths: l } = a.params, { rows: o } = a.params.grid; if (a.virtualSize = (e + r) * t, a.virtualSize = Math.ceil(a.virtualSize / o) - r, a.$wrapperEl.css({ [i("width")]: `${a.virtualSize + r}px` }), n) { s.splice(0, s.length); const e = []; for (let t = 0, i; t < s.length; t += 1)i = s[t], l && (i = Math.floor(i)), s[t] < a.virtualSize + s[0] && e.push(i); s.push(...e) } }; a.grid = { initSlides: l, updateSlide: o, updateWrapperSize: d } }, function (e) { let { swiper: a } = e; Object.assign(a, { appendSlide: j.bind(a), prependSlide: K.bind(a), addSlide: U.bind(a), removeSlide: Q.bind(a), removeAllSlides: Z.bind(a) }) }, function (e) { let { swiper: a, extendParams: s, on: t } = e; s({ fadeEffect: { crossFade: !1, transformEl: null } }); J({ effect: "fade", swiper: a, on: t, setTranslate: () => { const { slides: e } = a, s = a.params.fadeEffect; for (let t = 0; t < e.length; t += 1) { const e = a.slides.eq(t), i = e[0].swiperSlideOffset; let r = -i; a.params.virtualTranslate || (r -= a.translate); let n = 0; a.isHorizontal() || (n = r, r = 0); const l = a.params.fadeEffect.crossFade ? Math.max(1 - Math.abs(e[0].progress), 0) : 1 + Math.min(Math.max(e[0].progress, -1), 0), o = ee(s, e); o.css({ opacity: l }).transform(`translate3d(${r}px, ${n}px, 0px)`) } }, setTransition: e => { const { transformEl: s } = a.params.fadeEffect, t = s ? a.slides.find(s) : a.slides; t.transition(e), ae({ swiper: a, duration: e, transformEl: s, allSlides: !0 }) }, overwriteParams: () => ({ slidesPerView: 1, slidesPerGroup: 1, watchSlidesProgress: !0, spaceBetween: 0, virtualTranslate: !a.params.cssMode }) }) }, function (e) { let { swiper: a, extendParams: s, on: t } = e; s({ cubeEffect: { slideShadows: !0, shadow: !0, shadowOffset: 20, shadowScale: .94 } }); const r = (e, a, s) => { let t = s ? e.find(".swiper-slide-shadow-left") : e.find(".swiper-slide-shadow-top"), i = s ? e.find(".swiper-slide-shadow-right") : e.find(".swiper-slide-shadow-bottom"); 0 === t.length && (t = d(`<div class="swiper-slide-shadow-${s ? "left" : "top"}"></div>`), e.append(t)), 0 === i.length && (i = d(`<div class="swiper-slide-shadow-${s ? "right" : "bottom"}"></div>`), e.append(i)), t.length && (t[0].style.opacity = Math.max(-a, 0)), i.length && (i[0].style.opacity = Math.max(a, 0)) }, n = () => { const { $el: e, $wrapperEl: s, slides: t, width: i, height: n, rtlTranslate: l, size: o, browser: p } = a, c = a.params.cubeEffect, m = a.isHorizontal(), u = a.virtual && a.params.virtual.enabled; let h = 0, g; c.shadow && (m ? (g = s.find(".swiper-cube-shadow"), 0 === g.length && (g = d("<div class=\"swiper-cube-shadow\"></div>"), s.append(g)), g.css({ height: `${i}px` })) : (g = e.find(".swiper-cube-shadow"), 0 === g.length && (g = d("<div class=\"swiper-cube-shadow\"></div>"), e.append(g)))); for (let e = 0; e < t.length; e += 1) { const a = t.eq(e); let s = e; u && (s = parseInt(a.attr("data-swiper-slide-index"), 10)); let i = 90 * s, n = Math.floor(i / 360); l && (i = -i, n = Math.floor(-i / 360)); const d = Math.max(Math.min(a[0].progress, 1), -1); let p = 0, g = 0, f = 0; 0 == s % 4 ? (p = 4 * -n * o, f = 0) : 0 == (s - 1) % 4 ? (p = 0, f = 4 * -n * o) : 0 == (s - 2) % 4 ? (p = o + 4 * n * o, f = o) : 0 == (s - 3) % 4 && (p = -o, f = 3 * o + 4 * o * n), l && (p = -p), m || (g = p, p = 0); const v = `rotateX(${m ? 0 : -i}deg) rotateY(${m ? i : 0}deg) translate3d(${p}px, ${g}px, ${f}px)`; 1 >= d && -1 < d && (h = 90 * s + 90 * d, l && (h = 90 * -s - 90 * d)), a.transform(v), c.slideShadows && r(a, d, m) } if (s.css({ "-webkit-transform-origin": `50% 50% -${o / 2}px`, "transform-origin": `50% 50% -${o / 2}px` }), c.shadow) if (m) g.transform(`translate3d(0px, ${i / 2 + c.shadowOffset}px, ${-i / 2}px) rotateX(90deg) rotateZ(0deg) scale(${c.shadowScale})`); else { const e = Math.abs(h) - 90 * Math.floor(Math.abs(h) / 90), a = 1.5 - (Math.sin(2 * e * Math.PI / 360) / 2 + Math.cos(2 * e * Math.PI / 360) / 2), s = c.shadowScale, t = c.shadowScale / a, i = c.shadowOffset; g.transform(`scale3d(${s}, 1, ${t}) translate3d(0px, ${n / 2 + i}px, ${-n / 2 / t}px) rotateX(-90deg)`) } const f = p.isSafari || p.isWebView ? -o / 2 : 0; s.transform(`translate3d(0px,0,${f}px) rotateX(${a.isHorizontal() ? 0 : h}deg) rotateY(${a.isHorizontal() ? -h : 0}deg)`), s[0].style.setProperty("--swiper-cube-translate-z", `${f}px`) }; J({ effect: "cube", swiper: a, on: t, setTranslate: n, setTransition: e => { const { $el: s, slides: t } = a; t.transition(e).find(".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left").transition(e), a.params.cubeEffect.shadow && !a.isHorizontal() && s.find(".swiper-cube-shadow").transition(e) }, recreateShadows: () => { const e = a.isHorizontal(); a.slides.each(a => { const s = Math.max(Math.min(a.progress, 1), -1); r(d(a), s, e) }) }, getEffectParams: () => a.params.cubeEffect, perspective: () => !0, overwriteParams: () => ({ slidesPerView: 1, slidesPerGroup: 1, watchSlidesProgress: !0, resistanceRatio: 0, spaceBetween: 0, centeredSlides: !1, virtualTranslate: !0 }) }) }, function (e) { let { swiper: a, extendParams: s, on: t } = e; s({ flipEffect: { slideShadows: !0, limitRotation: !0, transformEl: null } }); const r = (e, s, t) => { let i = a.isHorizontal() ? e.find(".swiper-slide-shadow-left") : e.find(".swiper-slide-shadow-top"), r = a.isHorizontal() ? e.find(".swiper-slide-shadow-right") : e.find(".swiper-slide-shadow-bottom"); 0 === i.length && (i = se(t, e, a.isHorizontal() ? "left" : "top")), 0 === r.length && (r = se(t, e, a.isHorizontal() ? "right" : "bottom")), i.length && (i[0].style.opacity = Math.max(-s, 0)), r.length && (r[0].style.opacity = Math.max(s, 0)) }; J({ effect: "flip", swiper: a, on: t, setTranslate: () => { const { slides: e, rtlTranslate: s } = a, t = a.params.flipEffect; for (let n = 0; n < e.length; n += 1) { const i = e.eq(n); let l = i[0].progress; a.params.flipEffect.limitRotation && (l = Math.max(Math.min(i[0].progress, 1), -1)); const o = i[0].swiperSlideOffset, d = -180 * l; let p = d, c = 0, m = a.params.cssMode ? -o - a.translate : -o, u = 0; a.isHorizontal() ? s && (p = -p) : (u = m, m = 0, c = -p, p = 0), i[0].style.zIndex = -Math.abs(Math.round(l)) + e.length, t.slideShadows && r(i, l, t); const h = `translate3d(${m}px, ${u}px, 0px) rotateX(${c}deg) rotateY(${p}deg)`, g = ee(t, i); g.transform(h) } }, setTransition: e => { const { transformEl: s } = a.params.flipEffect, t = s ? a.slides.find(s) : a.slides; t.transition(e).find(".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left").transition(e), ae({ swiper: a, duration: e, transformEl: s }) }, recreateShadows: () => { const e = a.params.flipEffect; a.slides.each(s => { const t = d(s); let i = t[0].progress; a.params.flipEffect.limitRotation && (i = Math.max(Math.min(s.progress, 1), -1)), r(t, i, e) }) }, getEffectParams: () => a.params.flipEffect, perspective: () => !0, overwriteParams: () => ({ slidesPerView: 1, slidesPerGroup: 1, watchSlidesProgress: !0, spaceBetween: 0, virtualTranslate: !a.params.cssMode }) }) }, function (e) { let { swiper: a, extendParams: s, on: t } = e; s({ coverflowEffect: { rotate: 50, stretch: 0, depth: 100, scale: 1, modifier: 1, slideShadows: !0, transformEl: null } }); J({ effect: "coverflow", swiper: a, on: t, setTranslate: () => { const { width: e, height: s, slides: t, slidesSizesGrid: r } = a, n = a.params.coverflowEffect, l = a.isHorizontal(), o = a.translate, d = l ? -o + e / 2 : -o + s / 2, p = l ? n.rotate : -n.rotate, c = n.depth; for (let e = 0, a = t.length; e < a; e += 1) { const a = t.eq(e), s = r[e], i = a[0].swiperSlideOffset, o = (d - i - s / 2) / s, m = "function" == typeof n.modifier ? n.modifier(o) : o * n.modifier; let u = l ? p * m : 0, h = l ? 0 : p * m, g = -c * Math.abs(m), f = n.stretch; "string" == typeof f && -1 !== f.indexOf("%") && (f = parseFloat(n.stretch) / 100 * s); let v = l ? 0 : f * m, w = l ? f * m : 0, b = 1 - (1 - n.scale) * Math.abs(m); .001 > Math.abs(w) && (w = 0), .001 > Math.abs(v) && (v = 0), .001 > Math.abs(g) && (g = 0), .001 > Math.abs(u) && (u = 0), .001 > Math.abs(h) && (h = 0), .001 > Math.abs(b) && (b = 0); const y = `translate3d(${w}px,${v}px,${g}px)  rotateX(${h}deg) rotateY(${u}deg) scale(${b})`, x = ee(n, a); if (x.transform(y), a[0].style.zIndex = -Math.abs(Math.round(m)) + 1, n.slideShadows) { let e = l ? a.find(".swiper-slide-shadow-left") : a.find(".swiper-slide-shadow-top"), s = l ? a.find(".swiper-slide-shadow-right") : a.find(".swiper-slide-shadow-bottom"); 0 === e.length && (e = se(n, a, l ? "left" : "top")), 0 === s.length && (s = se(n, a, l ? "right" : "bottom")), e.length && (e[0].style.opacity = 0 < m ? m : 0), s.length && (s[0].style.opacity = 0 < -m ? -m : 0) } } }, setTransition: e => { const { transformEl: s } = a.params.coverflowEffect, t = s ? a.slides.find(s) : a.slides; t.transition(e).find(".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left").transition(e) }, perspective: () => !0, overwriteParams: () => ({ watchSlidesProgress: !0 }) }) }, function (e) { let { swiper: a, extendParams: s, on: t } = e; s({ creativeEffect: { transformEl: null, limitProgress: 1, shadowPerProgress: !1, progressMultiplier: 1, perspective: !0, prev: { translate: [0, 0, 0], rotate: [0, 0, 0], opacity: 1, scale: 1 }, next: { translate: [0, 0, 0], rotate: [0, 0, 0], opacity: 1, scale: 1 } } }); const i = e => "string" == typeof e ? e : `${e}px`; J({ effect: "creative", swiper: a, on: t, setTranslate: () => { const { slides: e, $wrapperEl: s, slidesSizesGrid: t } = a, n = a.params.creativeEffect, { progressMultiplier: l } = n, o = a.params.centeredSlides; if (o) { const e = t[0] / 2 - a.params.slidesOffsetBefore || 0; s.transform(`translateX(calc(50% - ${e}px))`) } for (let s = 0; s < e.length; s += 1) { const d = e.eq(s), p = d[0].progress, c = Math.min(Math.max(d[0].progress, -n.limitProgress), n.limitProgress); let m = c; o || (m = Math.min(Math.max(d[0].originalProgress, -n.limitProgress), n.limitProgress)); const u = d[0].swiperSlideOffset, h = [a.params.cssMode ? -u - a.translate : -u, 0, 0], t = [0, 0, 0]; let r = !1; a.isHorizontal() || (h[1] = h[0], h[0] = 0); let g = { translate: [0, 0, 0], rotate: [0, 0, 0], scale: 1, opacity: 1 }; 0 > c ? (g = n.next, r = !0) : 0 < c && (g = n.prev, r = !0), h.forEach((e, a) => { h[a] = `calc(${e}px + (${i(g.translate[a])} * ${Math.abs(c * l)}))` }), t.forEach((e, a) => { t[a] = g.rotate[a] * Math.abs(c * l) }), d[0].style.zIndex = -Math.abs(Math.round(p)) + e.length; const f = h.join(", "), v = `rotateX(${t[0]}deg) rotateY(${t[1]}deg) rotateZ(${t[2]}deg)`, w = 0 > m ? `scale(${1 + (1 - g.scale) * m * l})` : `scale(${1 - (1 - g.scale) * m * l})`, b = 0 > m ? 1 + (1 - g.opacity) * m * l : 1 - (1 - g.opacity) * m * l; if (r && g.shadow || !r) { let e = d.children(".swiper-slide-shadow"); if (0 === e.length && g.shadow && (e = se(n, d)), e.length) { const a = n.shadowPerProgress ? c * (1 / n.limitProgress) : c; e[0].style.opacity = Math.min(Math.max(Math.abs(a), 0), 1) } } const y = ee(n, d); y.transform(`translate3d(${f}) ${v} ${w}`).css({ opacity: b }), g.origin && y.css("transform-origin", g.origin) } }, setTransition: e => { const { transformEl: s } = a.params.creativeEffect, t = s ? a.slides.find(s) : a.slides; t.transition(e).find(".swiper-slide-shadow").transition(e), ae({ swiper: a, duration: e, transformEl: s, allSlides: !0 }) }, perspective: () => a.params.creativeEffect.perspective, overwriteParams: () => ({ watchSlidesProgress: !0, virtualTranslate: !a.params.cssMode }) }) }, function (e) {
            let { swiper: a, extendParams: s, on: t } = e; s({ cardsEffect: { slideShadows: !0, transformEl: null, rotate: !0 } }); J({
                effect: "cards", swiper: a, on: t, setTranslate: () => {
                    const { slides: e, activeIndex: s } = a, t = a.params.cardsEffect, { startTranslate: r, isTouched: n } = a.touchEventsData, l = a.translate; for (let o = 0; o < e.length; o += 1) {
                        const i = e.eq(o), d = i[0].progress, p = Math.min(Math.max(d, -4), 4); let c = i[0].swiperSlideOffset; a.params.centeredSlides && !a.params.cssMode && a.$wrapperEl.transform(`translateX(${a.minTranslate()}px)`), a.params.centeredSlides && a.params.cssMode && (c -= e[0].swiperSlideOffset); let m = a.params.cssMode ? -c - a.translate : -c, u = 0; const h = -100 * Math.abs(p); let g = 1, f = -2 * p, v = 8 - .75 * Math.abs(p); const w = a.virtual && a.params.virtual.enabled ? a.virtual.from + o : o, b = (w === s || w === s - 1) && 0 < p && 1 > p && (n || a.params.cssMode) && l < r, y = (w === s || w === s + 1) && 0 > p && -1 < p && (n || a.params.cssMode) && l > r; if (b || y) { const e = (1 - Math.abs((Math.abs(p) - .5) / .5)) ** .5; f += -28 * p * e, g += -.5 * e, v += 96 * e, u = `${-25 * e * Math.abs(p)}%` } if (m = 0 > p ? `calc(${m}px + (${v * Math.abs(p)}%))` : 0 < p ? `calc(${m}px + (-${v * Math.abs(p)}%))` : `${m}px`, !a.isHorizontal()) { const e = u; u = m, m = e } const x = 0 > p ? `${1 + (1 - g) * p}` : `${1 - (1 - g) * p}`, E = `
      translate3d(${m}, ${u}, ${h}px)
      rotateZ(${t.rotate ? f : 0}deg)
      scale(${x})
    `; if (t.slideShadows) { let e = i.find(".swiper-slide-shadow"); 0 === e.length && (e = se(t, i)), e.length && (e[0].style.opacity = Math.min(Math.max((Math.abs(p) - .5) / .5, 0), 1)) } i[0].style.zIndex = -Math.abs(Math.round(d)) + e.length; const C = ee(t, i); C.transform(E)
                    }
                }, setTransition: e => { const { transformEl: s } = a.params.cardsEffect, t = s ? a.slides.find(s) : a.slides; t.transition(e).find(".swiper-slide-shadow").transition(e), ae({ swiper: a, duration: e, transformEl: s }) }, perspective: () => !0, overwriteParams: () => ({ watchSlidesProgress: !0, virtualTranslate: !a.params.cssMode })
            })
        }]), fe
    })
